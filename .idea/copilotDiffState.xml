<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/discord.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/discord.md" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/package.json">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/package.json" />
              <option name="originalContent" value="{&#10;  &quot;name&quot;: &quot;cbaguette&quot;,&#10;  &quot;version&quot;: &quot;1.0.0&quot;,&#10;  &quot;description&quot;: &quot;A C to Baguette language translator&quot;,&#10;  &quot;main&quot;: &quot;dist/main.js&quot;,&#10;  &quot;bin&quot;: {&#10;    &quot;cbaguette&quot;: &quot;dist/main.js&quot;&#10;  },&#10;  &quot;scripts&quot;: {&#10;    &quot;build&quot;: &quot;tsc&quot;,&#10;    &quot;start&quot;: &quot;node dist/main.js&quot;,&#10;    &quot;test&quot;: &quot;jest&quot;&#10;  },&#10;  &quot;dependencies&quot;: f{&#10;    &quot;commander&quot;: &quot;^12.1.0&quot;&#10;  },&#10;  &quot;devDependencies&quot;: {&#10;    &quot;@types/jest&quot;: &quot;^30.0.0&quot;,&#10;    &quot;@types/node&quot;: &quot;^20.14.9&quot;,&#10;    &quot;jest&quot;: &quot;^30.0.5&quot;,&#10;    &quot;ts-jest&quot;: &quot;^29.4.1&quot;,&#10;    &quot;typescript&quot;: &quot;^5.5.3&quot;&#10;  },&#10;  &quot;private&quot;: true&#10;}&#10;" />
              <option name="updatedContent" value="{&#10;  &quot;name&quot;: &quot;cbaguette&quot;,&#10;  &quot;version&quot;: &quot;1.0.0&quot;,&#10;  &quot;description&quot;: &quot;A C to Baguette language translator&quot;,&#10;  &quot;main&quot;: &quot;dist/main.js&quot;,&#10;  &quot;bin&quot;: {&#10;    &quot;cbaguette&quot;: &quot;dist/main.js&quot;&#10;  },&#10;  &quot;scripts&quot;: {&#10;    &quot;build&quot;: &quot;tsc&quot;,&#10;    &quot;start&quot;: &quot;node dist/main.js&quot;,&#10;    &quot;test&quot;: &quot;jest&quot;&#10;  },&#10;  &quot;dependencies&quot;: {&#10;    &quot;commander&quot;: &quot;^12.1.0&quot;&#10;  },&#10;  &quot;devDependencies&quot;: {&#10;    &quot;@types/jest&quot;: &quot;^30.0.0&quot;,&#10;    &quot;@types/node&quot;: &quot;^20.14.9&quot;,&#10;    &quot;jest&quot;: &quot;^30.0.5&quot;,&#10;    &quot;ts-jest&quot;: &quot;^29.4.1&quot;,&#10;    &quot;typescript&quot;: &quot;^5.5.3&quot;&#10;  },&#10;  &quot;private&quot;: true&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/debug.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/debug.ts" />
              <option name="updatedContent" value="import { BaguetteLexer, Token, TokenType } from '../lexer';&#10;import { reversedTable } from '../keywords';&#10;&#10;// Script de débogage pour tester la reconnaissance des mots-clés français&#10;const codeBaguette = `&#10;énumération State { INIT, RUNNING };&#10;classe Data { entier value; };&#10;néant process(classe Data *d) {&#10;    statique entier count = 0;&#10;    enfonctionde (count) {&#10;        lorsque 0:&#10;            arrêter;&#10;        pardéfaut:&#10;            retourner;&#10;    }&#10;}`;&#10;&#10;// Créer un lexer C et tokenizer le code&#10;const baguetteLexer = new BaguetteLexer(codeBaguette);&#10;const tokens = baguetteLexer.tokenize();&#10;&#10;// Afficher tous les tokens et vérifier s'ils sont reconnus comme mots-clés&#10;console.log('Tokens générés:');&#10;tokens.forEach((token: Token, index: number) =&gt; {&#10;    const isKeyword = token.type === TokenType.KEYWORD;&#10;    console.log(`Token ${index}: &quot;${token.value}&quot; (${token.type})${isKeyword ? ' - MOT-CLÉ' : ''}`);&#10;    &#10;    if (isKeyword) {&#10;        console.log(`  Traduction: &quot;${reversedTable[token.value]}&quot;`);&#10;    }&#10;});&#10;&#10;// Afficher la table de traduction inversée pour les mots-clés problématiques&#10;console.log('\nTable de traduction inversée pour les mots-clés problématiques:');&#10;const problematicKeywords = ['néant', 'énumération', 'classe', 'entier', 'statique', 'enfonctionde', 'lorsque', 'arrêter', 'pardéfaut', 'retourner'];&#10;problematicKeywords.forEach(keyword =&gt; {&#10;    console.log(`&quot;${keyword}&quot; -&gt; &quot;${reversedTable[keyword]}&quot;`);&#10;});" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/keywords.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/keywords.ts" />
              <option name="originalContent" value="export const table = {&#10;    alignas: 'alignercomme',&#10;    alignof: 'alignementde',&#10;    auto: 'automatique',&#10;    bool: 'boule',&#10;    break: 'arrêter',&#10;    case: 'lorsque',&#10;    char: 'caractère',&#10;    const: 'constante',&#10;    constexpr: 'expressionconstante',&#10;    continue: 'continuer',&#10;    default: 'pardéfaut',&#10;    do: 'faire',&#10;    double: 'flottantprécis',&#10;    else: 'sinon',&#10;    enum: 'énumération',&#10;    extern: 'externe',&#10;    false: 'faux',&#10;    float: 'flottant',&#10;    for: 'pour',&#10;    goto: 'allerà',&#10;    if: 'si',&#10;    inline: 'linéarisé',&#10;    int: 'entier',&#10;    long: 'entierlong',&#10;    nullptr: 'pointeurverslenéant',&#10;    restrict: 'restreint',&#10;    return: 'retourner',&#10;    short: 'entiercourt',&#10;    signed: 'ouijeveuxlesigne',&#10;    sizeof: 'taillede',&#10;    static: 'statique',&#10;    static_assert: 'ouijesuissurque',&#10;    struct: 'classe',&#10;    switch: 'enfonctionde',&#10;    thread_local: 'fillocal',&#10;    true: 'vrai',&#10;    typedef: 'enregistrertype',&#10;    typeof: 'typede',&#10;    typeof_unqual: 'typedequalifié',&#10;    union: 'union',&#10;    unsigned: 'jmencarrelaracedusigne',&#10;    void: 'néant',&#10;    volatile: 'volatile',&#10;    while: 'tantque',&#10;};&#10;    char: 'caractère',&#10;export const reversedTable = Object.fromEntries(Object.entries(table).map(([key, value]) =&gt; [value, key]));&#10;    float: 'flottant',&#10;    char: 'caractère',&#10;    float: 'flottant',&#10;" />
              <option name="updatedContent" value="// Définition des mots-clés C avec leurs équivalents en français&#10;export interface KeywordMapping {&#10;    originalKeyword: string;      // Mot-clé C original&#10;    translatedKeyword: string;    // Version française&#10;    category: KeywordCategory;    // Catégorie du mot-clé&#10;    description?: string;         // Description optionnelle&#10;}&#10;&#10;// Catégories de mots-clés&#10;export enum KeywordCategory {&#10;    TYPE = 'type',                // Types de données&#10;    CONTROL_FLOW = 'control',     // Contrôle de flux&#10;    STORAGE = 'storage',          // Spécificateurs de stockage&#10;    OPERATOR = 'operator',        // Opérateurs&#10;    QUALIFIER = 'qualifier',      // Qualificateurs&#10;    CONSTANT = 'constant',        // Constantes&#10;    OTHER = 'other'               // Autres&#10;}&#10;&#10;// Définition structurée des mots-clés&#10;export const KEYWORDS: KeywordMapping[] = [&#10;    // Types de données&#10;    { originalKeyword: 'void', translatedKeyword: 'néant', category: KeywordCategory.TYPE, description: 'Type vide' },&#10;    { originalKeyword: 'char', translatedKeyword: 'caractère', category: KeywordCategory.TYPE, description: 'Caractère' },&#10;    { originalKeyword: 'int', translatedKeyword: 'entier', category: KeywordCategory.TYPE, description: 'Entier' },&#10;    { originalKeyword: 'float', translatedKeyword: 'flottant', category: KeywordCategory.TYPE, description: 'Nombre à virgule flottante' },&#10;    { originalKeyword: 'double', translatedKeyword: 'flottantprécis', category: KeywordCategory.TYPE, description: 'Flottant double précision' },&#10;    { originalKeyword: 'short', translatedKeyword: 'entiercourt', category: KeywordCategory.TYPE, description: 'Entier court' },&#10;    { originalKeyword: 'long', translatedKeyword: 'entierlong', category: KeywordCategory.TYPE, description: 'Entier long' },&#10;    { originalKeyword: 'signed', translatedKeyword: 'ouijeveuxlesigne', category: KeywordCategory.TYPE, description: 'Avec signe' },&#10;    { originalKeyword: 'unsigned', translatedKeyword: 'jmencarrelaracedusigne', category: KeywordCategory.TYPE, description: 'Sans signe' },&#10;    { originalKeyword: 'bool', translatedKeyword: 'boule', category: KeywordCategory.TYPE, description: 'Booléen' },&#10;    &#10;    // Structures de contrôle&#10;    { originalKeyword: 'if', translatedKeyword: 'si', category: KeywordCategory.CONTROL_FLOW, description: 'Condition si' },&#10;    { originalKeyword: 'else', translatedKeyword: 'sinon', category: KeywordCategory.CONTROL_FLOW, description: 'Condition sinon' },&#10;    { originalKeyword: 'switch', translatedKeyword: 'enfonctionde', category: KeywordCategory.CONTROL_FLOW, description: 'Sélection multiple' },&#10;    { originalKeyword: 'case', translatedKeyword: 'lorsque', category: KeywordCategory.CONTROL_FLOW, description: 'Cas dans un switch' },&#10;    { originalKeyword: 'default', translatedKeyword: 'pardéfaut', category: KeywordCategory.CONTROL_FLOW, description: 'Cas par défaut' },&#10;    { originalKeyword: 'for', translatedKeyword: 'pour', category: KeywordCategory.CONTROL_FLOW, description: 'Boucle pour' },&#10;    { originalKeyword: 'while', translatedKeyword: 'tantque', category: KeywordCategory.CONTROL_FLOW, description: 'Boucle tant que' },&#10;    { originalKeyword: 'do', translatedKeyword: 'faire', category: KeywordCategory.CONTROL_FLOW, description: 'Boucle faire... tant que' },&#10;    { originalKeyword: 'break', translatedKeyword: 'arrêter', category: KeywordCategory.CONTROL_FLOW, description: 'Sortir d\'une boucle' },&#10;    { originalKeyword: 'continue', translatedKeyword: 'continuer', category: KeywordCategory.CONTROL_FLOW, description: 'Passer à l\'itération suivante' },&#10;    { originalKeyword: 'return', translatedKeyword: 'retourner', category: KeywordCategory.CONTROL_FLOW, description: 'Retourner une valeur' },&#10;    { originalKeyword: 'goto', translatedKeyword: 'allerà', category: KeywordCategory.CONTROL_FLOW, description: 'Aller à un label' },&#10;    &#10;    // Spécificateurs de stockage&#10;    { originalKeyword: 'auto', translatedKeyword: 'automatique', category: KeywordCategory.STORAGE, description: 'Variable automatique' },&#10;    { originalKeyword: 'static', translatedKeyword: 'statique', category: KeywordCategory.STORAGE, description: 'Variable statique' },&#10;    { originalKeyword: 'extern', translatedKeyword: 'externe', category: KeywordCategory.STORAGE, description: 'Variable externe' },&#10;    { originalKeyword: 'typedef', translatedKeyword: 'enregistrertype', category: KeywordCategory.STORAGE, description: 'Définition de type' },&#10;    { originalKeyword: 'thread_local', translatedKeyword: 'fillocal', category: KeywordCategory.STORAGE, description: 'Variable locale au thread' },&#10;    &#10;    // Qualificateurs&#10;    { originalKeyword: 'const', translatedKeyword: 'constante', category: KeywordCategory.QUALIFIER, description: 'Valeur constante' },&#10;    { originalKeyword: 'volatile', translatedKeyword: 'volatile', category: KeywordCategory.QUALIFIER, description: 'Variable volatile' },&#10;    { originalKeyword: 'restrict', translatedKeyword: 'restreint', category: KeywordCategory.QUALIFIER, description: 'Pointeur non aliasé' },&#10;    { originalKeyword: 'inline', translatedKeyword: 'linéarisé', category: KeywordCategory.QUALIFIER, description: 'Fonction en ligne' },&#10;    &#10;    // Types composés et opérations&#10;    { originalKeyword: 'struct', translatedKeyword: 'classe', category: KeywordCategory.TYPE, description: 'Structure' },&#10;    { originalKeyword: 'union', translatedKeyword: 'union', category: KeywordCategory.TYPE, description: 'Union' },&#10;    { originalKeyword: 'enum', translatedKeyword: 'énumération', category: KeywordCategory.TYPE, description: 'Énumération' },&#10;    { originalKeyword: 'sizeof', translatedKeyword: 'taillede', category: KeywordCategory.OPERATOR, description: 'Taille en octets' },&#10;    &#10;    // Constantes&#10;    { originalKeyword: 'true', translatedKeyword: 'vrai', category: KeywordCategory.CONSTANT, description: 'Vrai' },&#10;    { originalKeyword: 'false', translatedKeyword: 'faux', category: KeywordCategory.CONSTANT, description: 'Faux' },&#10;    { originalKeyword: 'nullptr', translatedKeyword: 'pointeurverslenéant', category: KeywordCategory.CONSTANT, description: 'Pointeur nul' },&#10;    &#10;    // Fonctionnalités C11/C++&#10;    { originalKeyword: 'alignas', translatedKeyword: 'alignercomme', category: KeywordCategory.QUALIFIER, description: 'Alignement' },&#10;    { originalKeyword: 'alignof', translatedKeyword: 'alignementde', category: KeywordCategory.OPERATOR, description: 'Obtenir l\'alignement' },&#10;    { originalKeyword: 'constexpr', translatedKeyword: 'expressionconstante', category: KeywordCategory.QUALIFIER, description: 'Expression constante' },&#10;    { originalKeyword: 'static_assert', translatedKeyword: 'ouijesuissurque', category: KeywordCategory.OTHER, description: 'Assertion statique' },&#10;    { originalKeyword: 'typeof', translatedKeyword: 'typede', category: KeywordCategory.OPERATOR, description: 'Type de l\'expression' },&#10;    { originalKeyword: 'typeof_unqual', translatedKeyword: 'typedequalifié', category: KeywordCategory.OPERATOR, description: 'Type de l\'expression sans qualificateurs' }&#10;];&#10;&#10;// Création des tables de mapping C-&gt;Baguette et Baguette-&gt;C&#10;export const table: Record&lt;string, string&gt; = Object.fromEntries(&#10;    KEYWORDS.map(({ originalKeyword, translatedKeyword }) =&gt; [originalKeyword, translatedKeyword])&#10;);&#10;&#10;export const reversedTable: Record&lt;string, string&gt; = Object.fromEntries(&#10;    KEYWORDS.map(({ originalKeyword, translatedKeyword }) =&gt; [translatedKeyword, originalKeyword])&#10;);&#10;&#10;// Fonction utilitaire pour obtenir tous les mots-clés d'une catégorie&#10;export function getKeywordsByCategory(category: KeywordCategory): KeywordMapping[] {&#10;    return KEYWORDS.filter(keyword =&gt; keyword.category === category);&#10;}&#10;&#10;// Fonction pour vérifier si un mot est un mot-clé original (C)&#10;export function isCKeyword(word: string): boolean {&#10;    return Object.keys(table).includes(word);&#10;}&#10;&#10;// Fonction pour vérifier si un mot est un mot-clé traduit (Baguette)&#10;export function isBaguetteKeyword(word: string): boolean {&#10;    return Object.keys(reversedTable).includes(word);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/lexer.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/lexer.ts" />
              <option name="originalContent" value="import { table, reversedTable } from './keywords';&#10;&#10;// Types de tokens&#10;export enum TokenType {&#10;    KEYWORD = 'keyword',&#10;    IDENTIFIER = 'identifier',&#10;    STRING_LITERAL = 'string',&#10;    CHAR_LITERAL = 'char',&#10;    NUMBER = 'number',&#10;    PREPROCESSOR = 'preprocessor',&#10;    COMMENT_BLOCK = 'comment_block',&#10;    COMMENT_LINE = 'comment_line',&#10;    OPERATOR = 'operator',&#10;    PUNCTUATION = 'punctuation',&#10;    WHITESPACE = 'whitespace',&#10;    NEWLINE = 'newline',&#10;    OTHER = 'other'&#10;}&#10;&#10;export interface Token {&#10;    type: TokenType;&#10;    value: string;&#10;    line: number;&#10;    column: number;&#10;}&#10;&#10;// Classe de base pour les lexers&#10;class BaseLexer {&#10;    protected code: string;&#10;    protected position: number = 0;&#10;    protected line: number = 1;&#10;    protected column: number = 1;&#10;    protected keywords: Set&lt;string&gt;;&#10;&#10;    constructor(code: string) {&#10;        this.code = code;&#10;        this.keywords = new Set();&#10;    }&#10;&#10;    public tokenize(): Token[] {&#10;        const tokens: Token[] = [];&#10;&#10;        while (this.position &lt; this.code.length) {&#10;            const token = this.nextToken();&#10;            if (token) {&#10;                tokens.push(token);&#10;            }&#10;        }&#10;&#10;        return tokens;&#10;    }&#10;&#10;    protected nextToken(): Token | null {&#10;        if (this.position &gt;= this.code.length) {&#10;            return null;&#10;        }&#10;&#10;        const char = this.peek();&#10;        const startLine = this.line;&#10;        const startColumn = this.column;&#10;&#10;        // Espaces blancs&#10;        if (/\s/.test(char)) {&#10;            return this.readWhitespace(startLine, startColumn);&#10;        }&#10;&#10;        // Commentaires de bloc&#10;        if (char === '/' &amp;&amp; this.peek(1) === '*') {&#10;            return this.readBlockComment(startLine, startColumn);&#10;        }&#10;&#10;        // Commentaires de ligne&#10;        if (char === '/' &amp;&amp; this.peek(1) === '/') {&#10;            return this.readLineComment(startLine, startColumn);&#10;        }&#10;&#10;        // Directives de préprocesseur&#10;        if (char === '#' &amp;&amp; (this.column === 1 || this.isWhitespaceBeforeCurrent())) {&#10;            return this.readPreprocessor(startLine, startColumn);&#10;        }&#10;&#10;        // Chaînes de caractères&#10;        if (char === '&quot;') {&#10;            return this.readString(startLine, startColumn);&#10;        }&#10;&#10;        // Caractères&#10;        if (char === '\'') {&#10;            return this.readChar(startLine, startColumn);&#10;        }&#10;&#10;        // Nombres&#10;        if (/[0-9]/.test(char) || (char === '.' &amp;&amp; /[0-9]/.test(this.peek(1)))) {&#10;            return this.readNumber(startLine, startColumn);&#10;        }&#10;&#10;        // Identifiants et mots-clés&#10;        if (/[a-zA-Z_]/.test(char)) {&#10;            return this.readIdentifierOrKeyword(startLine, startColumn);&#10;        }&#10;&#10;        // Opérateurs et ponctuation&#10;        return this.readOperatorOrPunctuation(startLine, startColumn);&#10;    }&#10;&#10;    protected readWhitespace(startLine: number, startColumn: number): Token {&#10;        let value = '';&#10;&#10;        while (this.position &lt; this.code.length &amp;&amp; /\s/.test(this.peek())) {&#10;            const char = this.advance();&#10;            value += char;&#10;&#10;            if (char === '\n') {&#10;                return {&#10;                    type: TokenType.NEWLINE,&#10;                    value,&#10;                    line: startLine,&#10;                    column: startColumn&#10;                };&#10;            }&#10;        }&#10;&#10;        return {&#10;            type: TokenType.WHITESPACE,&#10;            value,&#10;            line: startLine,&#10;            column: startColumn&#10;        };&#10;    }&#10;&#10;    protected readBlockComment(startLine: number, startColumn: number): Token {&#10;        let value = '';&#10;        value += this.advance(); // '/'&#10;        value += this.advance(); // '*'&#10;&#10;        while (this.position &lt; this.code.length) {&#10;            if (this.peek() === '*' &amp;&amp; this.peek(1) === '/') {&#10;                value += this.advance(); // '*'&#10;                value += this.advance(); // '/'&#10;                break;&#10;            }&#10;            value += this.advance();&#10;        }&#10;&#10;        return {&#10;            type: TokenType.COMMENT_BLOCK,&#10;            value,&#10;            line: startLine,&#10;            column: startColumn&#10;        };&#10;    }&#10;&#10;    protected readLineComment(startLine: number, startColumn: number): Token {&#10;        let value = '';&#10;        value += this.advance(); // '/'&#10;        value += this.advance(); // '/'&#10;&#10;        while (this.position &lt; this.code.length &amp;&amp; this.peek() !== '\n') {&#10;            value += this.advance();&#10;        }&#10;&#10;        return {&#10;            type: TokenType.COMMENT_LINE,&#10;            value,&#10;            line: startLine,&#10;            column: startColumn&#10;        };&#10;    }&#10;&#10;    protected readPreprocessor(startLine: number, startColumn: number): Token {&#10;        let value = '';&#10;        value += this.advance(); // '#'&#10;&#10;        // Ignorer les espaces après le #&#10;        while (this.position &lt; this.code.length &amp;&amp; /\s/.test(this.peek()) &amp;&amp; this.peek() !== '\n') {&#10;            value += this.advance();&#10;        }&#10;&#10;        // Lire la directive&#10;        while (this.position &lt; this.code.length &amp;&amp; this.peek() !== '\n') {&#10;            // Gestion des lignes de continuation&#10;            if (this.peek() === '\\' &amp;&amp; this.peek(1) === '\n') {&#10;                value += this.advance(); // '\'&#10;                value += this.advance(); // '\n'&#10;                continue;&#10;            }&#10;            value += this.advance();&#10;        }&#10;&#10;        return {&#10;            type: TokenType.PREPROCESSOR,&#10;            value,&#10;            line: startLine,&#10;            column: startColumn&#10;        };&#10;    }&#10;&#10;    protected readString(startLine: number, startColumn: number): Token {&#10;        let value = '';&#10;        value += this.advance(); // '&quot;'&#10;&#10;        while (this.position &lt; this.code.length &amp;&amp; this.peek() !== '&quot;') {&#10;            if (this.peek() === '\\') {&#10;                value += this.advance(); // '\'&#10;                if (this.position &lt; this.code.length) {&#10;                    value += this.advance(); // caractère échappé&#10;                }&#10;            } else {&#10;                value += this.advance();&#10;            }&#10;        }&#10;&#10;        if (this.position &lt; this.code.length) {&#10;            value += this.advance(); // '&quot;'&#10;        }&#10;&#10;        return {&#10;            type: TokenType.STRING_LITERAL,&#10;            value,&#10;            line: startLine,&#10;            column: startColumn&#10;        };&#10;    }&#10;&#10;    protected readChar(startLine: number, startColumn: number): Token {&#10;        let value = '';&#10;        value += this.advance(); // '\''&#10;&#10;        while (this.position &lt; this.code.length &amp;&amp; this.peek() !== '\'') {&#10;            if (this.peek() === '\\') {&#10;                value += this.advance(); // '\'&#10;                if (this.position &lt; this.code.length) {&#10;                    value += this.advance(); // caractère échappé&#10;                }&#10;            } else {&#10;                value += this.advance();&#10;            }&#10;        }&#10;&#10;        if (this.position &lt; this.code.length) {&#10;            value += this.advance(); // '\''&#10;        }&#10;&#10;        return {&#10;            type: TokenType.CHAR_LITERAL,&#10;            value,&#10;            line: startLine,&#10;            column: startColumn&#10;        };&#10;    }&#10;&#10;    protected readNumber(startLine: number, startColumn: number): Token {&#10;        let value = '';&#10;&#10;        // Nombres hexadécimaux&#10;        if (this.peek() === '0' &amp;&amp; (this.peek(1) === 'x' || this.peek(1) === 'X')) {&#10;            value += this.advance(); // '0'&#10;            value += this.advance(); // 'x' ou 'X'&#10;&#10;            while (this.position &lt; this.code.length &amp;&amp; /[0-9a-fA-F]/.test(this.peek())) {&#10;                value += this.advance();&#10;            }&#10;        }&#10;        // Nombres octaux&#10;        else if (this.peek() === '0' &amp;&amp; /[0-7]/.test(this.peek(1))) {&#10;            value += this.advance(); // '0'&#10;&#10;            while (this.position &lt; this.code.length &amp;&amp; /[0-7]/.test(this.peek())) {&#10;                value += this.advance();&#10;            }&#10;        }&#10;        // Nombres décimaux&#10;        else {&#10;            // Partie entière&#10;            while (this.position &lt; this.code.length &amp;&amp; /[0-9]/.test(this.peek())) {&#10;                value += this.advance();&#10;            }&#10;&#10;            // Partie décimale&#10;            if (this.peek() === '.') {&#10;                value += this.advance(); // '.'&#10;&#10;                while (this.position &lt; this.code.length &amp;&amp; /[0-9]/.test(this.peek())) {&#10;                    value += this.advance();&#10;                }&#10;            }&#10;&#10;            // Exposant&#10;            if (this.peek() === 'e' || this.peek() === 'E') {&#10;                value += this.advance(); // 'e' ou 'E'&#10;&#10;                if (this.peek() === '+' || this.peek() === '-') {&#10;                    value += this.advance(); // '+' ou '-'&#10;                }&#10;&#10;                while (this.position &lt; this.code.length &amp;&amp; /[0-9]/.test(this.peek())) {&#10;                    value += this.advance();&#10;                }&#10;            }&#10;        }&#10;&#10;        // Suffixes (L, U, F, etc.)&#10;        while (this.position &lt; this.code.length &amp;&amp; /[a-zA-Z]/.test(this.peek())) {&#10;            value += this.advance();&#10;        }&#10;&#10;        return {&#10;            type: TokenType.NUMBER,&#10;            value,&#10;            line: startLine,&#10;            column: startColumn&#10;        };&#10;    }&#10;&#10;    protected readIdentifierOrKeyword(startLine: number, startColumn: number): Token {&#10;        let value = '';&#10;&#10;        while (this.position &lt; this.code.length &amp;&amp; /[a-zA-Z0-9_éèêëàâäôöùûüÿçÉÈÊËÀÂÄÔÖÙÛÜŸÇ]/.test(this.peek())) {&#10;            value += this.advance();&#10;        }&#10;&#10;        // Déterminer si c'est un mot-clé ou un identifiant&#10;        const type = this.keywords.has(value) ? TokenType.KEYWORD : TokenType.IDENTIFIER;&#10;&#10;        return {&#10;            type,&#10;            value,&#10;            line: startLine,&#10;            column: startColumn&#10;        };&#10;    }&#10;&#10;    protected readOperatorOrPunctuation(startLine: number, startColumn: number): Token {&#10;        let value = this.advance();&#10;&#10;        // Opérateurs composés de deux caractères&#10;        const twoCharOps = [&#10;            '++', '--', '+=', '-=', '*=', '/=', '%=', '&amp;=', '|=', '^=', '&lt;&lt;', '&gt;&gt;',&#10;            '==', '!=', '&lt;=', '&gt;=', '&amp;&amp;', '||', '-&gt;', '..'&#10;        ];&#10;&#10;        if (this.position &lt; this.code.length) {&#10;            const twoChars = value + this.peek();&#10;&#10;            if (twoCharOps.includes(twoChars)) {&#10;                value += this.advance();&#10;            }&#10;        }&#10;&#10;        // Déterminer si c'est un opérateur ou une ponctuation&#10;        const type = this.isOperator(value) ? TokenType.OPERATOR : TokenType.PUNCTUATION;&#10;&#10;        return {&#10;            type,&#10;            value,&#10;            line: startLine,&#10;            column: startColumn&#10;        };&#10;    }&#10;&#10;    protected advance(): string {&#10;        if (this.position &gt;= this.code.length) {&#10;            return '';&#10;        }&#10;&#10;        const char = this.code[this.position];&#10;        this.position++;&#10;&#10;        if (char === '\n') {&#10;            this.line++;&#10;            this.column = 1;&#10;        } else {&#10;            this.column++;&#10;        }&#10;&#10;        return char;&#10;    }&#10;&#10;    protected peek(offset: number = 0): string {&#10;        const pos = this.position + offset;&#10;&#10;        if (pos &gt;= this.code.length) {&#10;            return '';&#10;        }&#10;&#10;        return this.code[pos];&#10;    }&#10;&#10;    protected isWhitespaceBeforeCurrent(): boolean {&#10;        let pos = this.position - 1;&#10;&#10;        while (pos &gt;= 0 &amp;&amp; this.code[pos] !== '\n') {&#10;            if (!/\s/.test(this.code[pos])) {&#10;                return false;&#10;            }&#10;            pos--;&#10;        }&#10;&#10;        return true;&#10;    }&#10;&#10;    protected isOperator(value: string): boolean {&#10;        const operators = [&#10;            '+', '-', '*', '/', '%', '=', '!', '&lt;', '&gt;', '&amp;', '|', '^', '~',&#10;            '++', '--', '+=', '-=', '*=', '/=', '%=', '&amp;=', '|=', '^=',&#10;            '&lt;&lt;', '&gt;&gt;', '&lt;&lt;=', '&gt;&gt;=', '==', '!=', '&lt;=', '&gt;=', '&amp;&amp;', '||', '-&gt;'&#10;        ];&#10;&#10;        return operators.includes(value);&#10;    }&#10;}&#10;&#10;// Lexer spécifique pour le code C&#10;export class CLexer extends BaseLexer {&#10;    constructor(code: string) {&#10;        super(code);&#10;        // Définir les mots-clés C&#10;        this.keywords = new Set(Object.keys(table));&#10;    }&#10;}&#10;&#10;// Lexer spécifique pour le code C&#10;export class BaguetteLexer extends BaseLexer {&#10;    constructor(code: string) {&#10;        super(code);&#10;        // Définir les mots-clés C&#10;        this.keywords = new Set(Object.keys(reversedTable));&#10;    }&#10;}&#10;&#10;// Fonction pour traduire le code C vers C&#10;export function translateCToBaguette(code: string): string {&#10;    const cLexer = new CLexer(code);&#10;    const tokens = cLexer.tokenize();&#10;    return processTokensForTranslation(tokens);&#10;}&#10;&#10;// Fonction pour compiler le code C vers C&#10;export function compileBaguetteToC(code: string): string {&#10;    // Prétraitement pour gérer les problèmes d'encodage des caractères accentués&#10;    let normalizedCode = code;&#10;&#10;    // Remplacer les versions mal encodées des mots-clés français&#10;    if (code.includes('numration')) {&#10;        normalizedCode = normalizedCode.replace(/numration/g, 'énumération');&#10;    }&#10;    if (code.includes('nant')) {&#10;        normalizedCode = normalizedCode.replace(/nant/g, 'néant');&#10;    }&#10;    if (code.includes('arrter')) {&#10;        normalizedCode = normalizedCode.replace(/arrter/g, 'arrêter');&#10;    }&#10;    if (code.includes('pardfaut')) {&#10;        normalizedCode = normalizedCode.replace(/pardfaut/g, 'pardéfaut');&#10;    }&#10;&#10;    const baguetteLexer = new BaguetteLexer(normalizedCode);&#10;    let normalizedCode = code;&#10;&#10;    // Remplacer les versions mal encodées des mots-clés français&#10;    if (code.includes('numration')) {&#10;        normalizedCode = normalizedCode.replace(/numration/g, 'énumération');&#10;    }&#10;    if (code.includes('nant')) {&#10;        normalizedCode = normalizedCode.replace(/nant/g, 'néant');&#10;    }&#10;    if (code.includes('arrter')) {&#10;        normalizedCode = normalizedCode.replace(/arrter/g, 'arrêter');&#10;    }&#10;    if (code.includes('pardfaut')) {&#10;        normalizedCode = normalizedCode.replace(/pardfaut/g, 'pardéfaut');&#10;    }&#10;&#10;    const baguetteLexer = new BaguetteLexer(normalizedCode);&#10;    const tokens = baguetteLexer.tokenize();&#10;    return processTokensForCompilation(tokens);&#10;}&#10;&#10;// Traitement des tokens pour la traduction C -&gt; C&#10;function processTokensForTranslation(tokens: Token[]): string {&#10;    const result: string[] = [];&#10;&#10;    for (const token of tokens) {&#10;        if (token.type === TokenType.KEYWORD) {&#10;            // Remplacer uniquement les mots-clés C par leurs équivalents C&#10;            const translated = table[token.value];&#10;            if (translated) {&#10;                result.push(translated);&#10;            } else {&#10;            // Cas spéciaux pour les mots-clés avec accents&#10;            if (token.value === 'énumération' || token.value.includes('numération')) {&#10;                result.push('enum');&#10;            } else if (token.value === 'néant' || token.value.includes('néant')) {&#10;                result.push('void');&#10;            } else if (token.value === 'arrêter' || token.value.includes('arrêter')) {&#10;                result.push('break');&#10;            } else if (token.value === 'pardéfaut' || token.value.includes('pardéfaut')) {&#10;                result.push('default');&#10;            } else if (token.value === 'retourner' || token.value.includes('retourner')) {&#10;                result.push('return');&#10;            } else if (token.value === 'classe') {&#10;                result.push('struct');&#10;            } else if (token.value === 'entier') {&#10;                result.push('int');&#10;            } else if (token.value === 'statique') {&#10;                result.push('static');&#10;            } else if (token.value === 'enfonctionde') {&#10;                result.push('switch');&#10;            } else if (token.value === 'lorsque') {&#10;                result.push('case');&#10;            } else {&#10;                // Remplacer les autres mots-clés C par leurs équivalents C&#10;                const compiled = reversedTable[token.value];&#10;                if (compiled) {&#10;                    result.push(compiled);&#10;                } else {&#10;                    result.push(token.value);&#10;                }&#10;    }&#10;&#10;    return tokensToString(result);&#10;}&#10;&#10;// Traitement des tokens pour la compilation C -&gt; C&#10;function processTokensForCompilation(tokens: Token[]): string {&#10;    const result: string[] = [];&#10;&#10;    for (const token of tokens) {&#10;        if (token.type === TokenType.KEYWORD) {&#10;            // Cas spéciaux pour les mots-clés avec accents&#10;            if (token.value === 'énumération' || token.value.includes('numération')) {&#10;                result.push('enum');&#10;            } else if (token.value === 'néant' || token.value.includes('néant')) {&#10;                result.push('void');&#10;            } else if (token.value === 'arrêter' || token.value.includes('arrêter')) {&#10;                result.push('break');&#10;            } else if (token.value === 'pardéfaut' || token.value.includes('pardéfaut')) {&#10;                result.push('default');&#10;            } else if (token.value === 'retourner' || token.value.includes('retourner')) {&#10;                result.push('return');&#10;            } else if (token.value === 'classe') {&#10;                result.push('struct');&#10;            } else if (token.value === 'entier') {&#10;                result.push('int');&#10;            } else if (token.value === 'statique') {&#10;                result.push('static');&#10;            } else if (token.value === 'enfonctionde') {&#10;                result.push('switch');&#10;            } else if (token.value === 'lorsque') {&#10;                result.push('case');&#10;            } else {&#10;                // Remplacer les autres mots-clés C par leurs équivalents C&#10;                const compiled = reversedTable[token.value];&#10;                if (compiled) {&#10;                    result.push(compiled);&#10;                } else {&#10;                    result.push(token.value);&#10;                }&#10;            }&#10;        } else {&#10;            // Conserver les autres tokens tels quels&#10;            result.push(token.value);&#10;        }&#10;    }&#10;&#10;    return tokensToString(result);&#10;}&#10;&#10;// Fonction pour reconstituer le code à partir des tokens&#10;export function tokensToString(tokens: string[]): string {&#10;    return tokens.join('');&#10;}&#10;" />
              <option name="updatedContent" value="import { table, reversedTable } from './keywords';&#10;&#10;// Types de tokens&#10;export enum TokenType {&#10;    KEYWORD = 'keyword',&#10;    IDENTIFIER = 'identifier',&#10;    STRING_LITERAL = 'string',&#10;    CHAR_LITERAL = 'char',&#10;    NUMBER = 'number',&#10;    PREPROCESSOR = 'preprocessor',&#10;    COMMENT_BLOCK = 'comment_block',&#10;    COMMENT_LINE = 'comment_line',&#10;    OPERATOR = 'operator',&#10;    PUNCTUATION = 'punctuation',&#10;    WHITESPACE = 'whitespace',&#10;    NEWLINE = 'newline',&#10;    OTHER = 'other'&#10;}&#10;&#10;export interface Token {&#10;    type: TokenType;&#10;    value: string;&#10;    line: number;&#10;    column: number;&#10;}&#10;&#10;// Classe de base pour les lexers&#10;class BaseLexer {&#10;    protected code: string;&#10;    protected position: number = 0;&#10;    protected line: number = 1;&#10;    protected column: number = 1;&#10;    protected keywords: Set&lt;string&gt;;&#10;&#10;    constructor(code: string) {&#10;        this.code = code;&#10;        this.keywords = new Set();&#10;    }&#10;&#10;    public tokenize(): Token[] {&#10;        const tokens: Token[] = [];&#10;&#10;        while (this.position &lt; this.code.length) {&#10;            const token = this.nextToken();&#10;            if (token) {&#10;                tokens.push(token);&#10;            }&#10;        }&#10;&#10;        return tokens;&#10;    }&#10;&#10;    protected nextToken(): Token | null {&#10;        if (this.position &gt;= this.code.length) {&#10;            return null;&#10;        }&#10;&#10;        const char = this.peek();&#10;        const startLine = this.line;&#10;        const startColumn = this.column;&#10;&#10;        // Espaces blancs&#10;        if (/\s/.test(char)) {&#10;            return this.readWhitespace(startLine, startColumn);&#10;        }&#10;&#10;        // Commentaires de bloc&#10;        if (char === '/' &amp;&amp; this.peek(1) === '*') {&#10;            return this.readBlockComment(startLine, startColumn);&#10;        }&#10;&#10;        // Commentaires de ligne&#10;        if (char === '/' &amp;&amp; this.peek(1) === '/') {&#10;            return this.readLineComment(startLine, startColumn);&#10;        }&#10;&#10;        // Directives de préprocesseur&#10;        if (char === '#' &amp;&amp; (this.column === 1 || this.isWhitespaceBeforeCurrent())) {&#10;            return this.readPreprocessor(startLine, startColumn);&#10;        }&#10;&#10;        // Chaînes de caractères&#10;        if (char === '&quot;') {&#10;            return this.readString(startLine, startColumn);&#10;        }&#10;&#10;        // Caractères&#10;        if (char === '\'') {&#10;            return this.readChar(startLine, startColumn);&#10;        }&#10;&#10;        // Nombres&#10;        if (/[0-9]/.test(char) || (char === '.' &amp;&amp; /[0-9]/.test(this.peek(1)))) {&#10;            return this.readNumber(startLine, startColumn);&#10;        }&#10;&#10;        // Identifiants et mots-clés&#10;        if (/[a-zA-Z_éèêëàâäôöùûüÿçÉÈÊËÀÂÄÔÖÙÛÜŸÇ]/.test(char)) {&#10;            return this.readIdentifierOrKeyword(startLine, startColumn);&#10;        }&#10;&#10;        // Opérateurs et ponctuation&#10;        return this.readOperatorOrPunctuation(startLine, startColumn);&#10;    }&#10;&#10;    protected readWhitespace(startLine: number, startColumn: number): Token {&#10;        let value = '';&#10;&#10;        while (this.position &lt; this.code.length &amp;&amp; /\s/.test(this.peek())) {&#10;            const char = this.advance();&#10;            value += char;&#10;&#10;            if (char === '\n') {&#10;                return {&#10;                    type: TokenType.NEWLINE,&#10;                    value,&#10;                    line: startLine,&#10;                    column: startColumn&#10;                };&#10;            }&#10;        }&#10;&#10;        return {&#10;            type: TokenType.WHITESPACE,&#10;            value,&#10;            line: startLine,&#10;            column: startColumn&#10;        };&#10;    }&#10;&#10;    protected readBlockComment(startLine: number, startColumn: number): Token {&#10;        let value = '';&#10;        value += this.advance(); // '/'&#10;        value += this.advance(); // '*'&#10;&#10;        while (this.position &lt; this.code.length) {&#10;            if (this.peek() === '*' &amp;&amp; this.peek(1) === '/') {&#10;                value += this.advance(); // '*'&#10;                value += this.advance(); // '/'&#10;                break;&#10;            }&#10;            value += this.advance();&#10;        }&#10;&#10;        return {&#10;            type: TokenType.COMMENT_BLOCK,&#10;            value,&#10;            line: startLine,&#10;            column: startColumn&#10;        };&#10;    }&#10;&#10;    protected readLineComment(startLine: number, startColumn: number): Token {&#10;        let value = '';&#10;        value += this.advance(); // '/'&#10;        value += this.advance(); // '/'&#10;&#10;        while (this.position &lt; this.code.length &amp;&amp; this.peek() !== '\n') {&#10;            value += this.advance();&#10;        }&#10;&#10;        return {&#10;            type: TokenType.COMMENT_LINE,&#10;            value,&#10;            line: startLine,&#10;            column: startColumn&#10;        };&#10;    }&#10;&#10;    protected readPreprocessor(startLine: number, startColumn: number): Token {&#10;        let value = '';&#10;        value += this.advance(); // '#'&#10;&#10;        // Ignorer les espaces après le #&#10;        while (this.position &lt; this.code.length &amp;&amp; /\s/.test(this.peek()) &amp;&amp; this.peek() !== '\n') {&#10;            value += this.advance();&#10;        }&#10;&#10;        // Lire la directive&#10;        while (this.position &lt; this.code.length &amp;&amp; this.peek() !== '\n') {&#10;            // Gestion des lignes de continuation&#10;            if (this.peek() === '\\' &amp;&amp; this.peek(1) === '\n') {&#10;                value += this.advance(); // '\'&#10;                value += this.advance(); // '\n'&#10;                continue;&#10;            }&#10;            value += this.advance();&#10;        }&#10;&#10;        return {&#10;            type: TokenType.PREPROCESSOR,&#10;            value,&#10;            line: startLine,&#10;            column: startColumn&#10;        };&#10;    }&#10;&#10;    protected readString(startLine: number, startColumn: number): Token {&#10;        let value = '';&#10;        value += this.advance(); // '&quot;'&#10;&#10;        while (this.position &lt; this.code.length &amp;&amp; this.peek() !== '&quot;') {&#10;            if (this.peek() === '\\') {&#10;                value += this.advance(); // '\'&#10;                if (this.position &lt; this.code.length) {&#10;                    value += this.advance(); // caractère échappé&#10;                }&#10;            } else {&#10;                value += this.advance();&#10;            }&#10;        }&#10;&#10;        if (this.position &lt; this.code.length) {&#10;            value += this.advance(); // '&quot;'&#10;        }&#10;&#10;        return {&#10;            type: TokenType.STRING_LITERAL,&#10;            value,&#10;            line: startLine,&#10;            column: startColumn&#10;        };&#10;    }&#10;&#10;    protected readChar(startLine: number, startColumn: number): Token {&#10;        let value = '';&#10;        value += this.advance(); // '\''&#10;&#10;        while (this.position &lt; this.code.length &amp;&amp; this.peek() !== '\'') {&#10;            if (this.peek() === '\\') {&#10;                value += this.advance(); // '\'&#10;                if (this.position &lt; this.code.length) {&#10;                    value += this.advance(); // caractère échappé&#10;                }&#10;            } else {&#10;                value += this.advance();&#10;            }&#10;        }&#10;&#10;        if (this.position &lt; this.code.length) {&#10;            value += this.advance(); // '\''&#10;        }&#10;&#10;        return {&#10;            type: TokenType.CHAR_LITERAL,&#10;            value,&#10;            line: startLine,&#10;            column: startColumn&#10;        };&#10;    }&#10;&#10;    protected readNumber(startLine: number, startColumn: number): Token {&#10;        let value = '';&#10;&#10;        // Nombres hexadécimaux&#10;        if (this.peek() === '0' &amp;&amp; (this.peek(1) === 'x' || this.peek(1) === 'X')) {&#10;            value += this.advance(); // '0'&#10;            value += this.advance(); // 'x' ou 'X'&#10;&#10;            while (this.position &lt; this.code.length &amp;&amp; /[0-9a-fA-F]/.test(this.peek())) {&#10;                value += this.advance();&#10;            }&#10;        }&#10;        // Nombres octaux&#10;        else if (this.peek() === '0' &amp;&amp; /[0-7]/.test(this.peek(1))) {&#10;            value += this.advance(); // '0'&#10;&#10;            while (this.position &lt; this.code.length &amp;&amp; /[0-7]/.test(this.peek())) {&#10;                value += this.advance();&#10;            }&#10;        }&#10;        // Nombres décimaux&#10;        else {&#10;            // Partie entière&#10;            while (this.position &lt; this.code.length &amp;&amp; /[0-9]/.test(this.peek())) {&#10;                value += this.advance();&#10;            }&#10;&#10;            // Partie décimale&#10;            if (this.peek() === '.') {&#10;                value += this.advance(); // '.'&#10;&#10;                while (this.position &lt; this.code.length &amp;&amp; /[0-9]/.test(this.peek())) {&#10;                    value += this.advance();&#10;                }&#10;            }&#10;&#10;            // Exposant&#10;            if (this.peek() === 'e' || this.peek() === 'E') {&#10;                value += this.advance(); // 'e' ou 'E'&#10;&#10;                if (this.peek() === '+' || this.peek() === '-') {&#10;                    value += this.advance(); // '+' ou '-'&#10;                }&#10;&#10;                while (this.position &lt; this.code.length &amp;&amp; /[0-9]/.test(this.peek())) {&#10;                    value += this.advance();&#10;                }&#10;            }&#10;        }&#10;&#10;        // Suffixes (L, U, F, etc.)&#10;        while (this.position &lt; this.code.length &amp;&amp; /[a-zA-Z]/.test(this.peek())) {&#10;            value += this.advance();&#10;        }&#10;&#10;        return {&#10;            type: TokenType.NUMBER,&#10;            value,&#10;            line: startLine,&#10;            column: startColumn&#10;        };&#10;    }&#10;&#10;    protected readIdentifierOrKeyword(startLine: number, startColumn: number): Token {&#10;        let value = '';&#10;&#10;        while (this.position &lt; this.code.length &amp;&amp; /[a-zA-Z0-9_éèêëàâäôöùûüÿçÉÈÊËÀÂÄÔÖÙÛÜŸÇ]/.test(this.peek())) {&#10;            value += this.advance();&#10;        }&#10;&#10;        // Déterminer si c'est un mot-clé ou un identifiant&#10;        const type = this.keywords.has(value) ? TokenType.KEYWORD : TokenType.IDENTIFIER;&#10;&#10;        return {&#10;            type,&#10;            value,&#10;            line: startLine,&#10;            column: startColumn&#10;        };&#10;    }&#10;&#10;    protected readOperatorOrPunctuation(startLine: number, startColumn: number): Token {&#10;        let value = this.advance();&#10;&#10;        // Opérateurs composés de deux caractères&#10;        const twoCharOps = [&#10;            '++', '--', '+=', '-=', '*=', '/=', '%=', '&amp;=', '|=', '^=', '&lt;&lt;', '&gt;&gt;',&#10;            '==', '!=', '&lt;=', '&gt;=', '&amp;&amp;', '||', '-&gt;', '..'&#10;        ];&#10;&#10;        if (this.position &lt; this.code.length) {&#10;            const twoChars = value + this.peek();&#10;&#10;            if (twoCharOps.includes(twoChars)) {&#10;                value += this.advance();&#10;            }&#10;        }&#10;&#10;        // Déterminer si c'est un opérateur ou une ponctuation&#10;        const type = this.isOperator(value) ? TokenType.OPERATOR : TokenType.PUNCTUATION;&#10;&#10;        return {&#10;            type,&#10;            value,&#10;            line: startLine,&#10;            column: startColumn&#10;        };&#10;    }&#10;&#10;    protected advance(): string {&#10;        if (this.position &gt;= this.code.length) {&#10;            return '';&#10;        }&#10;&#10;        const char = this.code[this.position];&#10;        this.position++;&#10;&#10;        if (char === '\n') {&#10;            this.line++;&#10;            this.column = 1;&#10;        } else {&#10;            this.column++;&#10;        }&#10;&#10;        return char;&#10;    }&#10;&#10;    protected peek(offset: number = 0): string {&#10;        const pos = this.position + offset;&#10;&#10;        if (pos &gt;= this.code.length) {&#10;            return '';&#10;        }&#10;&#10;        return this.code[pos];&#10;    }&#10;&#10;    protected isWhitespaceBeforeCurrent(): boolean {&#10;        let pos = this.position - 1;&#10;&#10;        while (pos &gt;= 0 &amp;&amp; this.code[pos] !== '\n') {&#10;            if (!/\s/.test(this.code[pos])) {&#10;                return false;&#10;            }&#10;            pos--;&#10;        }&#10;&#10;        return true;&#10;    }&#10;&#10;    protected isOperator(value: string): boolean {&#10;        const operators = [&#10;            '+', '-', '*', '/', '%', '=', '!', '&lt;', '&gt;', '&amp;', '|', '^', '~',&#10;            '++', '--', '+=', '-=', '*=', '/=', '%=', '&amp;=', '|=', '^=',&#10;            '&lt;&lt;', '&gt;&gt;', '&lt;&lt;=', '&gt;&gt;=', '==', '!=', '&lt;=', '&gt;=', '&amp;&amp;', '||', '-&gt;'&#10;        ];&#10;&#10;        return operators.includes(value);&#10;    }&#10;}&#10;&#10;// Lexer spécifique pour le code C&#10;export class CLexer extends BaseLexer {&#10;    constructor(code: string) {&#10;        super(code);&#10;        // Définir les mots-clés C&#10;        this.keywords = new Set(Object.keys(table));&#10;    }&#10;}&#10;&#10;// Lexer spécifique pour le code C&#10;export class BaguetteLexer extends BaseLexer {&#10;    constructor(code: string) {&#10;        super(code);&#10;        // Définir les mots-clés C&#10;        this.keywords = new Set(Object.keys(reversedTable));&#10;    }&#10;}&#10;&#10;// Fonction pour traduire le code C vers C&#10;export function translateCToBaguette(code: string): string {&#10;    const cLexer = new CLexer(code);&#10;    const tokens = cLexer.tokenize();&#10;    return processTokensForTranslation(tokens);&#10;}&#10;&#10;// Fonction pour compiler le code C vers C&#10;export function compileBaguetteToC(code: string): string {&#10;    const baguetteLexer = new BaguetteLexer(code);&#10;    const tokens = baguetteLexer.tokenize();&#10;    return processTokensForCompilation(tokens);&#10;}&#10;&#10;// Traitement des tokens pour la traduction C -&gt; C&#10;function processTokensForTranslation(tokens: Token[]): string {&#10;    const result: string[] = [];&#10;&#10;    for (const token of tokens) {&#10;        if (token.type === TokenType.KEYWORD) {&#10;            // Remplacer uniquement les mots-clés C par leurs équivalents C&#10;            const translated = table[token.value];&#10;            if (translated) {&#10;                result.push(translated);&#10;            } else {&#10;                result.push(token.value);&#10;            }&#10;        } else {&#10;            // Conserver les autres tokens tels quels&#10;            result.push(token.value);&#10;        }&#10;    }&#10;&#10;    return tokensToString(result);&#10;}&#10;&#10;// Traitement des tokens pour la compilation C -&gt; C&#10;function processTokensForCompilation(tokens: Token[]): string {&#10;    const result: string[] = [];&#10;&#10;    for (const token of tokens) {&#10;        if (token.type === TokenType.KEYWORD) {&#10;            // Remplacer uniquement les mots-clés C par leurs équivalents C&#10;            const compiled = reversedTable[token.value];&#10;            if (compiled) {&#10;                result.push(compiled);&#10;            } else {&#10;                result.push(token.value);&#10;            }&#10;        } else {&#10;            // Conserver les autres tokens tels quels&#10;            result.push(token.value);&#10;        }&#10;    }&#10;&#10;    return tokensToString(result);&#10;}&#10;&#10;// Fonction pour reconstituer le code à partir des tokens&#10;export function tokensToString(tokens: string[]): string {&#10;    return tokens.join('');&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/newLexer.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/newLexer.ts" />
              <option name="updatedContent" value="import { table, reversedTable } from './keywords';&#10;&#10;// Types de tokens&#10;export enum TokenType {&#10;    KEYWORD = 'keyword',&#10;    IDENTIFIER = 'identifier',&#10;    STRING_LITERAL = 'string',&#10;    CHAR_LITERAL = 'char',&#10;    NUMBER = 'number',&#10;    PREPROCESSOR = 'preprocessor',&#10;    COMMENT_BLOCK = 'comment_block',&#10;    COMMENT_LINE = 'comment_line',&#10;    OPERATOR = 'operator',&#10;    PUNCTUATION = 'punctuation',&#10;    WHITESPACE = 'whitespace',&#10;    NEWLINE = 'newline',&#10;    OTHER = 'other'&#10;}&#10;&#10;export interface Token {&#10;    type: TokenType;&#10;    value: string;&#10;    line: number;&#10;    column: number;&#10;}&#10;&#10;export class CLexer {&#10;    private code: string;&#10;    private position: number = 0;&#10;    private line: number = 1;&#10;    private column: number = 1;&#10;    private translationTable: Record&lt;string, string&gt;;&#10;    private isCompileMode: boolean;&#10;    private keywords: Set&lt;string&gt;;&#10;&#10;    constructor(code: string, isCompileMode: boolean = false) {&#10;        this.code = code;&#10;        this.isCompileMode = isCompileMode;&#10;        &#10;        // Déterminer la table de traduction en fonction du mode&#10;        this.translationTable = isCompileMode ? reversedTable : table;&#10;        &#10;        // Créer un ensemble de mots-clés à partir de la table appropriée&#10;        this.keywords = new Set(&#10;            isCompileMode &#10;                ? Object.values(this.translationTable) &#10;                : Object.keys(this.translationTable)&#10;        );&#10;    }&#10;&#10;    public tokenize(): Token[] {&#10;        const tokens: Token[] = [];&#10;        &#10;        while (this.position &lt; this.code.length) {&#10;            const token = this.nextToken();&#10;            if (token) {&#10;                tokens.push(token);&#10;            }&#10;        }&#10;        &#10;        return tokens;&#10;    }&#10;&#10;    private nextToken(): Token | null {&#10;        if (this.position &gt;= this.code.length) {&#10;            return null;&#10;        }&#10;&#10;        const char = this.peek();&#10;        const startLine = this.line;&#10;        const startColumn = this.column;&#10;&#10;        // Espaces blancs&#10;        if (/\s/.test(char)) {&#10;            return this.readWhitespace(startLine, startColumn);&#10;        }&#10;        &#10;        // Commentaires de bloc&#10;        if (char === '/' &amp;&amp; this.peek(1) === '*') {&#10;            return this.readBlockComment(startLine, startColumn);&#10;        }&#10;        &#10;        // Commentaires de ligne&#10;        if (char === '/' &amp;&amp; this.peek(1) === '/') {&#10;            return this.readLineComment(startLine, startColumn);&#10;        }&#10;        &#10;        // Directives de préprocesseur&#10;        if (char === '#' &amp;&amp; (this.column === 1 || this.isWhitespaceBeforeCurrent())) {&#10;            return this.readPreprocessor(startLine, startColumn);&#10;        }&#10;        &#10;        // Chaînes de caractères&#10;        if (char === '&quot;') {&#10;            return this.readString(startLine, startColumn);&#10;        }&#10;        &#10;        // Caractères&#10;        if (char === '\'') {&#10;            return this.readChar(startLine, startColumn);&#10;        }&#10;        &#10;        // Nombres&#10;        if (/[0-9]/.test(char) || (char === '.' &amp;&amp; /[0-9]/.test(this.peek(1)))) {&#10;            return this.readNumber(startLine, startColumn);&#10;        }&#10;        &#10;        // Identifiants et mots-clés&#10;        if (/[a-zA-Z_]/.test(char)) {&#10;            return this.readIdentifierOrKeyword(startLine, startColumn);&#10;        }&#10;        &#10;        // Opérateurs et ponctuation&#10;        return this.readOperatorOrPunctuation(startLine, startColumn);&#10;    }&#10;&#10;    private readWhitespace(startLine: number, startColumn: number): Token {&#10;        let value = '';&#10;        &#10;        while (this.position &lt; this.code.length &amp;&amp; /\s/.test(this.peek())) {&#10;            const char = this.advance();&#10;            value += char;&#10;            &#10;            if (char === '\n') {&#10;                return {&#10;                    type: TokenType.NEWLINE,&#10;                    value,&#10;                    line: startLine,&#10;                    column: startColumn&#10;                };&#10;            }&#10;        }&#10;        &#10;        return {&#10;            type: TokenType.WHITESPACE,&#10;            value,&#10;            line: startLine,&#10;            column: startColumn&#10;        };&#10;    }&#10;&#10;    private readBlockComment(startLine: number, startColumn: number): Token {&#10;        let value = '';&#10;        value += this.advance(); // '/'&#10;        value += this.advance(); // '*'&#10;        &#10;        while (this.position &lt; this.code.length) {&#10;            if (this.peek() === '*' &amp;&amp; this.peek(1) === '/') {&#10;                value += this.advance(); // '*'&#10;                value += this.advance(); // '/'&#10;                break;&#10;            }&#10;            value += this.advance();&#10;        }&#10;        &#10;        return {&#10;            type: TokenType.COMMENT_BLOCK,&#10;            value,&#10;            line: startLine,&#10;            column: startColumn&#10;        };&#10;    }&#10;&#10;    private readLineComment(startLine: number, startColumn: number): Token {&#10;        let value = '';&#10;        value += this.advance(); // '/'&#10;        value += this.advance(); // '/'&#10;        &#10;        while (this.position &lt; this.code.length &amp;&amp; this.peek() !== '\n') {&#10;            value += this.advance();&#10;        }&#10;        &#10;        return {&#10;            type: TokenType.COMMENT_LINE,&#10;            value,&#10;            line: startLine,&#10;            column: startColumn&#10;        };&#10;    }&#10;&#10;    private readPreprocessor(startLine: number, startColumn: number): Token {&#10;        let value = '';&#10;        value += this.advance(); // '#'&#10;        &#10;        // Ignorer les espaces après le #&#10;        while (this.position &lt; this.code.length &amp;&amp; /\s/.test(this.peek()) &amp;&amp; this.peek() !== '\n') {&#10;            value += this.advance();&#10;        }&#10;        &#10;        // Lire la directive&#10;        while (this.position &lt; this.code.length &amp;&amp; this.peek() !== '\n') {&#10;            // Gestion des lignes de continuation&#10;            if (this.peek() === '\\' &amp;&amp; this.peek(1) === '\n') {&#10;                value += this.advance(); // '\'&#10;                value += this.advance(); // '\n'&#10;                continue;&#10;            }&#10;            value += this.advance();&#10;        }&#10;        &#10;        return {&#10;            type: TokenType.PREPROCESSOR,&#10;            value,&#10;            line: startLine,&#10;            column: startColumn&#10;        };&#10;    }&#10;&#10;    private readString(startLine: number, startColumn: number): Token {&#10;        let value = '';&#10;        value += this.advance(); // '&quot;'&#10;        &#10;        while (this.position &lt; this.code.length &amp;&amp; this.peek() !== '&quot;') {&#10;            if (this.peek() === '\\') {&#10;                value += this.advance(); // '\'&#10;                if (this.position &lt; this.code.length) {&#10;                    value += this.advance(); // caractère échappé&#10;                }&#10;            } else {&#10;                value += this.advance();&#10;            }&#10;        }&#10;        &#10;        if (this.position &lt; this.code.length) {&#10;            value += this.advance(); // '&quot;'&#10;        }&#10;        &#10;        return {&#10;            type: TokenType.STRING_LITERAL,&#10;            value,&#10;            line: startLine,&#10;            column: startColumn&#10;        };&#10;    }&#10;&#10;    private readChar(startLine: number, startColumn: number): Token {&#10;        let value = '';&#10;        value += this.advance(); // '\''&#10;        &#10;        while (this.position &lt; this.code.length &amp;&amp; this.peek() !== '\'') {&#10;            if (this.peek() === '\\') {&#10;                value += this.advance(); // '\'&#10;                if (this.position &lt; this.code.length) {&#10;                    value += this.advance(); // caractère échappé&#10;                }&#10;            } else {&#10;                value += this.advance();&#10;            }&#10;        }&#10;        &#10;        if (this.position &lt; this.code.length) {&#10;            value += this.advance(); // '\''&#10;        }&#10;        &#10;        return {&#10;            type: TokenType.CHAR_LITERAL,&#10;            value,&#10;            line: startLine,&#10;            column: startColumn&#10;        };&#10;    }&#10;&#10;    private readNumber(startLine: number, startColumn: number): Token {&#10;        let value = '';&#10;        &#10;        // Nombres hexadécimaux&#10;        if (this.peek() === '0' &amp;&amp; (this.peek(1) === 'x' || this.peek(1) === 'X')) {&#10;            value += this.advance(); // '0'&#10;            value += this.advance(); // 'x' ou 'X'&#10;            &#10;            while (this.position &lt; this.code.length &amp;&amp; /[0-9a-fA-F]/.test(this.peek())) {&#10;                value += this.advance();&#10;            }&#10;        } &#10;        // Nombres octaux&#10;        else if (this.peek() === '0' &amp;&amp; /[0-7]/.test(this.peek(1))) {&#10;            value += this.advance(); // '0'&#10;            &#10;            while (this.position &lt; this.code.length &amp;&amp; /[0-7]/.test(this.peek())) {&#10;                value += this.advance();&#10;            }&#10;        } &#10;        // Nombres décimaux&#10;        else {&#10;            // Partie entière&#10;            while (this.position &lt; this.code.length &amp;&amp; /[0-9]/.test(this.peek())) {&#10;                value += this.advance();&#10;            }&#10;            &#10;            // Partie décimale&#10;            if (this.peek() === '.') {&#10;                value += this.advance(); // '.'&#10;                &#10;                while (this.position &lt; this.code.length &amp;&amp; /[0-9]/.test(this.peek())) {&#10;                    value += this.advance();&#10;                }&#10;            }&#10;            &#10;            // Exposant&#10;            if (this.peek() === 'e' || this.peek() === 'E') {&#10;                value += this.advance(); // 'e' ou 'E'&#10;                &#10;                if (this.peek() === '+' || this.peek() === '-') {&#10;                    value += this.advance(); // '+' ou '-'&#10;                }&#10;                &#10;                while (this.position &lt; this.code.length &amp;&amp; /[0-9]/.test(this.peek())) {&#10;                    value += this.advance();&#10;                }&#10;            }&#10;        }&#10;        &#10;        // Suffixes (L, U, F, etc.)&#10;        while (this.position &lt; this.code.length &amp;&amp; /[a-zA-Z]/.test(this.peek())) {&#10;            value += this.advance();&#10;        }&#10;        &#10;        return {&#10;            type: TokenType.NUMBER,&#10;            value,&#10;            line: startLine,&#10;            column: startColumn&#10;        };&#10;    }&#10;&#10;    private readIdentifierOrKeyword(startLine: number, startColumn: number): Token {&#10;        let value = '';&#10;        &#10;        while (this.position &lt; this.code.length &amp;&amp; /[a-zA-Z0-9_]/.test(this.peek())) {&#10;            value += this.advance();&#10;        }&#10;        &#10;        // Déterminer si c'est un mot-clé ou un identifiant&#10;        const type = this.keywords.has(value) ? TokenType.KEYWORD : TokenType.IDENTIFIER;&#10;        &#10;        return {&#10;            type,&#10;            value,&#10;            line: startLine,&#10;            column: startColumn&#10;        };&#10;    }&#10;&#10;    private readOperatorOrPunctuation(startLine: number, startColumn: number): Token {&#10;        let value = this.advance();&#10;        &#10;        // Opérateurs composés de deux caractères&#10;        const twoCharOps = [&#10;            '++', '--', '+=', '-=', '*=', '/=', '%=', '&amp;=', '|=', '^=', '&lt;&lt;', '&gt;&gt;', &#10;            '==', '!=', '&lt;=', '&gt;=', '&amp;&amp;', '||', '-&gt;', '..'&#10;        ];&#10;        &#10;        if (this.position &lt; this.code.length) {&#10;            const twoChars = value + this.peek();&#10;            &#10;            if (twoCharOps.includes(twoChars)) {&#10;                value += this.advance();&#10;            }&#10;        }&#10;        &#10;        // Déterminer si c'est un opérateur ou une ponctuation&#10;        const type = this.isOperator(value) ? TokenType.OPERATOR : TokenType.PUNCTUATION;&#10;        &#10;        return {&#10;            type,&#10;            value,&#10;            line: startLine,&#10;            column: startColumn&#10;        };&#10;    }&#10;&#10;    private advance(): string {&#10;        if (this.position &gt;= this.code.length) {&#10;            return '';&#10;        }&#10;        &#10;        const char = this.code[this.position];&#10;        this.position++;&#10;        &#10;        if (char === '\n') {&#10;            this.line++;&#10;            this.column = 1;&#10;        } else {&#10;            this.column++;&#10;        }&#10;        &#10;        return char;&#10;    }&#10;&#10;    private peek(offset: number = 0): string {&#10;        const pos = this.position + offset;&#10;        &#10;        if (pos &gt;= this.code.length) {&#10;            return '';&#10;        }&#10;        &#10;        return this.code[pos];&#10;    }&#10;&#10;    private isWhitespaceBeforeCurrent(): boolean {&#10;        let pos = this.position - 1;&#10;        &#10;        while (pos &gt;= 0 &amp;&amp; this.code[pos] !== '\n') {&#10;            if (!/\s/.test(this.code[pos])) {&#10;                return false;&#10;            }&#10;            pos--;&#10;        }&#10;        &#10;        return true;&#10;    }&#10;&#10;    private isOperator(value: string): boolean {&#10;        const operators = [&#10;            '+', '-', '*', '/', '%', '=', '!', '&lt;', '&gt;', '&amp;', '|', '^', '~',&#10;            '++', '--', '+=', '-=', '*=', '/=', '%=', '&amp;=', '|=', '^=',&#10;            '&lt;&lt;', '&gt;&gt;', '&lt;&lt;=', '&gt;&gt;=', '==', '!=', '&lt;=', '&gt;=', '&amp;&amp;', '||', '-&gt;'&#10;        ];&#10;        &#10;        return operators.includes(value);&#10;    }&#10;}&#10;&#10;// Fonction principale pour le lexing&#10;export function lexer(code: string, isCompileMode: boolean = false): string[] {&#10;    const cLexer = new CLexer(code, isCompileMode);&#10;    const tokens = cLexer.tokenize();&#10;    &#10;    // Traiter les tokens et transformer les mots-clés selon le mode&#10;    return processTokens(tokens, isCompileMode);&#10;}&#10;&#10;// Traitement des tokens pour remplacer les mots-clés&#10;function processTokens(tokens: Token[], isCompileMode: boolean): string[] {&#10;    const translationTable = isCompileMode ? reversedTable : table;&#10;    const result: string[] = [];&#10;    &#10;    for (const token of tokens) {&#10;        if (token.type === TokenType.KEYWORD) {&#10;            // Remplacer uniquement les mots-clés&#10;            const translated = translationTable[token.value];&#10;            result.push(translated || token.value);&#10;        } else {&#10;            // Conserver les autres tokens tels quels&#10;            result.push(token.value);&#10;        }&#10;    }&#10;    &#10;    return result;&#10;}&#10;&#10;// Fonction pour reconstituer le code à partir des tokens&#10;export function tokensToString(tokens: string[]): string {&#10;    return tokens.join('');&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/tests/compilation.test.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/tests/compilation.test.ts" />
              <option name="originalContent" value="import { compileBaguetteToC } from '../lexer';&#10;&#10;describe('Compilation (C vers C)', () =&gt; {&#10;    test('Compilation de base', () =&gt; {&#10;        const codeBaguette = `&#10;        néant main() {&#10;            entier x = 10;&#10;            si (x &gt; 5) {&#10;                retourner;&#10;            }&#10;        }&#10;        `;&#10;&#10;        const expectedC = `&#10;        void main() {&#10;            int x = 10;&#10;            if (x &gt; 5) {&#10;                return;&#10;            }&#10;        }&#10;        `;&#10;&#10;        const compiledCode = compileBaguetteToC(codeBaguette);&#10;        expect(compiledCode.replace(/\s+/g, ' ')).toEqual(expectedC.replace(/\s+/g, ' '));&#10;    });&#10;&#10;    test('Compilation avec des mots-clés complexes', () =&gt; {&#10;        // Test complet&#10;        const codeBaguette = `&#10;        énumération State { INIT, RUNNING };&#10;        classe Data { entier value; };&#10;        néant process(classe Data *d) {&#10;            statique entier count = 0;&#10;            enfonctionde (count) {&#10;                lorsque 0:&#10;                    arrêter;&#10;                pardéfaut:&#10;                    retourner;&#10;            }&#10;        }&#10;        `;&#10;&#10;        const expectedC = `&#10;        enum State { INIT, RUNNING };&#10;        struct Data { int value; };&#10;        void process(struct Data *d) {&#10;            static int count = 0;&#10;            switch (count) {&#10;                case 0:&#10;                    break;&#10;                default:&#10;                    return;&#10;            }&#10;        }&#10;        `;&#10;&#10;        const compiledCode = compileBaguetteToC(codeBaguette);&#10;&#10;        // Comparaison mot par mot pour identifier le problème&#10;        const cleanedCompiled = compiledCode.replace(/\s+/g, ' ').trim();&#10;        const cleanedExpected = expectedC.replace(/\s+/g, ' ').trim();&#10;&#10;        expect(cleanedCompiled).toEqual(cleanedExpected);&#10;    });&#10;&#10;    test('Compilation d\'un extrait de test2.c', () =&gt; {&#10;        // Extrait du fichier test2.c&#10;        const codeBaguette = `&#10;        néant processState(classe ComplexStruct *s) {&#10;            si (s == NULL) {&#10;                retourner;&#10;            }&#10;            enfonctionde (s-&gt;currentState) {&#10;                lorsque INIT:&#10;                    arrêter;&#10;                pardéfaut:&#10;                    arrêter;&#10;            }&#10;        }`;&#10;&#10;        const expectedC = `&#10;        void processState(struct ComplexStruct *s) {&#10;            if (s == NULL) {&#10;                return;&#10;            }&#10;            switch (s-&gt;currentState) {&#10;                case INIT:&#10;                    break;&#10;                default:&#10;                    break;&#10;            }&#10;        }`;&#10;&#10;        const compiledCode = compileBaguetteToC(codeBaguette);&#10;        expect(compiledCode.replace(/\s+/g, ' ')).toEqual(expectedC.replace(/\s+/g, ' '));&#10;    });&#10;});&#10;" />
              <option name="updatedContent" value="import { compileBaguetteToC } from '../lexer';&#10;&#10;describe('Compilation (C vers C)', () =&gt; {&#10;    test('Compilation de base', () =&gt; {&#10;        const codeBaguette = `&#10;        néant main() {&#10;            entier x = 10;&#10;            si (x &gt; 5) {&#10;                retourner;&#10;            }&#10;        }&#10;        `;&#10;&#10;        const expectedC = `&#10;        void main() {&#10;            int x = 10;&#10;            if (x &gt; 5) {&#10;                return;&#10;            }&#10;        }&#10;        `;&#10;&#10;        const compiledCode = compileBaguetteToC(codeBaguette);&#10;        expect(compiledCode.replace(/\s+/g, ' ')).toEqual(expectedC.replace(/\s+/g, ' '));&#10;    });&#10;&#10;    test('Compilation avec des mots-clés complexes', () =&gt; {&#10;        // Test complet&#10;        const codeBaguette = `&#10;        énumération State { INIT, RUNNING };&#10;        classe Data { entier value; };&#10;        néant process(classe Data *d) {&#10;            statique entier count = 0;&#10;            enfonctionde (count) {&#10;                lorsque 0:&#10;                    arrêter;&#10;                pardéfaut:&#10;                    retourner;&#10;            }&#10;        }&#10;        `;&#10;&#10;        const expectedC = `&#10;        enum State { INIT, RUNNING };&#10;        struct Data { int value; };&#10;        void process(struct Data *d) {&#10;            static int count = 0;&#10;            switch (count) {&#10;                case 0:&#10;                    break;&#10;                default:&#10;                    return;&#10;            }&#10;        }&#10;        `;&#10;&#10;        const compiledCode = compileBaguetteToC(codeBaguette);&#10;&#10;        // Comparaison mot par mot pour identifier le problème&#10;        const cleanedCompiled = compiledCode.replace(/\s+/g, ' ').trim();&#10;        const cleanedExpected = expectedC.replace(/\s+/g, ' ').trim();&#10;&#10;        expect(cleanedCompiled).toEqual(cleanedExpected);&#10;    });&#10;&#10;    test('Compilation d\'un extrait de test2.c', () =&gt; {&#10;        // Extrait du fichier test2.c&#10;        const codeBaguette = `&#10;        néant processState(classe ComplexStruct *s) {&#10;            si (s == NULL) {&#10;                retourner;&#10;            }&#10;            enfonctionde (s-&gt;currentState) {&#10;                lorsque INIT:&#10;                    arrêter;&#10;                pardéfaut:&#10;                    arrêter;&#10;            }&#10;        }`;&#10;&#10;        const expectedC = `&#10;        void processState(struct ComplexStruct *s) {&#10;            if (s == NULL) {&#10;                return;&#10;            }&#10;            switch (s-&gt;currentState) {&#10;                case INIT:&#10;                    break;&#10;                default:&#10;                    break;&#10;            }&#10;        }`;&#10;&#10;        const compiledCode = compileBaguetteToC(codeBaguette);&#10;        expect(compiledCode.replace(/\s+/g, ' ')).toEqual(expectedC.replace(/\s+/g, ' '));&#10;    });&#10;&#10;    test('Compilation des types de données', () =&gt; {&#10;        const codeBaguette = `&#10;        caractère c = 'a';&#10;        entier i = 42;&#10;        flottant f = 3.14;&#10;        flottantprécis d = 3.141592653589793;&#10;        entiercourt s = 100;&#10;        entierlong l = 1000000L;&#10;        ouijeveuxlesigne entier si = -42;&#10;        jmencarrelaracedusigne entier ui = 42U;&#10;        boule b = vrai;&#10;        `;&#10;&#10;        const expectedC = `&#10;        char c = 'a';&#10;        int i = 42;&#10;        float f = 3.14;&#10;        double d = 3.141592653589793;&#10;        short s = 100;&#10;        long l = 1000000L;&#10;        signed int si = -42;&#10;        unsigned int ui = 42U;&#10;        bool b = true;&#10;        `;&#10;&#10;        const compiledCode = compileBaguetteToC(codeBaguette);&#10;        expect(compiledCode.replace(/\s+/g, ' ')).toEqual(expectedC.replace(/\s+/g, ' '));&#10;    });&#10;&#10;    test('Compilation des structures de contrôle', () =&gt; {&#10;        const codeBaguette = `&#10;        entier fibonacci(entier n) {&#10;            si (n &lt;= 1) {&#10;                retourner n;&#10;            } sinon {&#10;                retourner fibonacci(n-1) + fibonacci(n-2);&#10;            }&#10;        }&#10;        &#10;        néant loops() {&#10;            pour (entier i = 0; i &lt; 10; i++) {&#10;                si (i == 5) {&#10;                    continuer;&#10;                }&#10;                si (i == 8) {&#10;                    arrêter;&#10;                }&#10;            }&#10;            &#10;            entier j = 0;&#10;            tantque (j &lt; 5) {&#10;                j++;&#10;            }&#10;            &#10;            faire {&#10;                j--;&#10;            } tantque (j &gt; 0);&#10;        }&#10;        `;&#10;&#10;        const expectedC = `&#10;        int fibonacci(int n) {&#10;            if (n &lt;= 1) {&#10;                return n;&#10;            } else {&#10;                return fibonacci(n-1) + fibonacci(n-2);&#10;            }&#10;        }&#10;        &#10;        void loops() {&#10;            for (int i = 0; i &lt; 10; i++) {&#10;                if (i == 5) {&#10;                    continue;&#10;                }&#10;                if (i == 8) {&#10;                    break;&#10;                }&#10;            }&#10;            &#10;            int j = 0;&#10;            while (j &lt; 5) {&#10;                j++;&#10;            }&#10;            &#10;            do {&#10;                j--;&#10;            } while (j &gt; 0);&#10;        }&#10;        `;&#10;&#10;        const compiledCode = compileBaguetteToC(codeBaguette);&#10;        expect(compiledCode.replace(/\s+/g, ' ')).toEqual(expectedC.replace(/\s+/g, ' '));&#10;    });&#10;&#10;    test('Compilation des qualificateurs et spécificateurs de stockage', () =&gt; {&#10;        const codeBaguette = `&#10;        constante entier MAX_SIZE = 100;&#10;        volatile entier interrupt_flag;&#10;        statique entier counter = 0;&#10;        externe entier global_var;&#10;        automatique entier local_var;&#10;        &#10;        linéarisé entier square(entier x) {&#10;            retourner x * x;&#10;        }&#10;        &#10;        enregistrertype classe Point Point_t;&#10;        `;&#10;&#10;        const expectedC = `&#10;        const int MAX_SIZE = 100;&#10;        volatile int interrupt_flag;&#10;        static int counter = 0;&#10;        extern int global_var;&#10;        auto int local_var;&#10;        &#10;        inline int square(int x) {&#10;            return x * x;&#10;        }&#10;        &#10;        typedef struct Point Point_t;&#10;        `;&#10;&#10;        const compiledCode = compileBaguetteToC(codeBaguette);&#10;        expect(compiledCode.replace(/\s+/g, ' ')).toEqual(expectedC.replace(/\s+/g, ' '));&#10;    });&#10;&#10;    test('Compilation des opérateurs et constantes', () =&gt; {&#10;        const codeBaguette = `&#10;        néant test_operators() {&#10;            entier size = taillede(entier);&#10;            boule is_true = vrai;&#10;            boule is_false = faux;&#10;            entier* ptr = pointeurverslenéant;&#10;            &#10;            si (is_true &amp;&amp; !is_false) {&#10;                // Test passé&#10;            }&#10;        }&#10;        `;&#10;&#10;        const expectedC = `&#10;        void test_operators() {&#10;            int size = sizeof(int);&#10;            bool is_true = true;&#10;            bool is_false = false;&#10;            int* ptr = nullptr;&#10;            &#10;            if (is_true &amp;&amp; !is_false) {&#10;                // Test passé&#10;            }&#10;        }&#10;        `;&#10;&#10;        const compiledCode = compileBaguetteToC(codeBaguette);&#10;        expect(compiledCode.replace(/\s+/g, ' ')).toEqual(expectedC.replace(/\s+/g, ' '));&#10;    });&#10;&#10;    test('Compilation avec goto et étiquettes', () =&gt; {&#10;        const codeBaguette = `&#10;        néant test_goto() {&#10;            entier i = 0;&#10;            &#10;        boucle:&#10;            si (i &lt; 5) {&#10;                i++;&#10;                allerà boucle;&#10;            }&#10;            &#10;            retourner;&#10;        }&#10;        `;&#10;&#10;        const expectedC = `&#10;        void test_goto() {&#10;            int i = 0;&#10;            &#10;        boucle:&#10;            if (i &lt; 5) {&#10;                i++;&#10;                goto boucle;&#10;            }&#10;            &#10;            return;&#10;        }&#10;        `;&#10;&#10;        const compiledCode = compileBaguetteToC(codeBaguette);&#10;        expect(compiledCode.replace(/\s+/g, ' ')).toEqual(expectedC.replace(/\s+/g, ' '));&#10;    });&#10;&#10;    test('Compilation avec unions et énumérations complexes', () =&gt; {&#10;        const codeBaguette = `&#10;        énumération Color {&#10;            RED,&#10;            GREEN,&#10;            BLUE&#10;        };&#10;        &#10;        union Data {&#10;            entier i;&#10;            flottant f;&#10;            caractère c[4];&#10;        };&#10;        &#10;        classe Point {&#10;            entier x, y;&#10;            énumération Color color;&#10;        };&#10;        `;&#10;&#10;        const expectedC = `&#10;        enum Color {&#10;            RED,&#10;            GREEN,&#10;            BLUE&#10;        };&#10;        &#10;        union Data {&#10;            int i;&#10;            float f;&#10;            char c[4];&#10;        };&#10;        &#10;        struct Point {&#10;            int x, y;&#10;            enum Color color;&#10;        };&#10;        `;&#10;&#10;        const compiledCode = compileBaguetteToC(codeBaguette);&#10;        expect(compiledCode.replace(/\s+/g, ' ')).toEqual(expectedC.replace(/\s+/g, ' '));&#10;    });&#10;&#10;    test('Compilation avec mélange de français et d\'identifiants', () =&gt; {&#10;        const codeBaguette = `&#10;        néant calculateFactorial() {&#10;            entier number = 5;&#10;            entier result = 1;&#10;            &#10;            pour (entier i = 1; i &lt;= number; i++) {&#10;                result *= i;&#10;            }&#10;            &#10;            printf(&quot;Factorial de %d est %d\\n&quot;, number, result);&#10;        }&#10;        `;&#10;&#10;        const expectedC = `&#10;        void calculateFactorial() {&#10;            int number = 5;&#10;            int result = 1;&#10;            &#10;            for (int i = 1; i &lt;= number; i++) {&#10;                result *= i;&#10;            }&#10;            &#10;            printf(&quot;Factorial de %d est %d\\n&quot;, number, result);&#10;        }&#10;        `;&#10;&#10;        const compiledCode = compileBaguetteToC(codeBaguette);&#10;        expect(compiledCode.replace(/\s+/g, ' ')).toEqual(expectedC.replace(/\s+/g, ' '));&#10;    });&#10;&#10;    test('Compilation avec switch complexe et multiples cases', () =&gt; {&#10;        const codeBaguette = `&#10;        néant processCommand(entier cmd) {&#10;            enfonctionde (cmd) {&#10;                lorsque 1:&#10;                lorsque 2:&#10;                    printf(&quot;Commande simple\\n&quot;);&#10;                    arrêter;&#10;                    &#10;                lorsque 3:&#10;                    printf(&quot;Commande spéciale\\n&quot;);&#10;                    // Pas de break volontaire&#10;                    &#10;                lorsque 4:&#10;                    printf(&quot;Commande avancée\\n&quot;);&#10;                    arrêter;&#10;                    &#10;                pardéfaut:&#10;                    printf(&quot;Commande inconnue\\n&quot;);&#10;                    arrêter;&#10;            }&#10;        }&#10;        `;&#10;&#10;        const expectedC = `&#10;        void processCommand(int cmd) {&#10;            switch (cmd) {&#10;                case 1:&#10;                case 2:&#10;                    printf(&quot;Commande simple\\n&quot;);&#10;                    break;&#10;                    &#10;                case 3:&#10;                    printf(&quot;Commande spéciale\\n&quot;);&#10;                    // Pas de break volontaire&#10;                    &#10;                case 4:&#10;                    printf(&quot;Commande avancée\\n&quot;);&#10;                    break;&#10;                    &#10;                default:&#10;                    printf(&quot;Commande inconnue\\n&quot;);&#10;                    break;&#10;            }&#10;        }&#10;        `;&#10;&#10;        const compiledCode = compileBaguetteToC(codeBaguette);&#10;        expect(compiledCode.replace(/\s+/g, ' ')).toEqual(expectedC.replace(/\s+/g, ' '));&#10;    });&#10;&#10;    test('Compilation avec pointeurs et arithmétique', () =&gt; {&#10;        const codeBaguette = `&#10;        néant pointer_arithmetic() {&#10;            entier arr[10];&#10;            entier* ptr = arr;&#10;            entier** double_ptr = &amp;ptr;&#10;            &#10;            pour (entier i = 0; i &lt; 10; i++) {&#10;                *(ptr + i) = i * 2;&#10;            }&#10;            &#10;            entier size = taillede(arr) / taillede(entier);&#10;            printf(&quot;Taille du tableau: %d\\n&quot;, size);&#10;        }&#10;        `;&#10;&#10;        const expectedC = `&#10;        void pointer_arithmetic() {&#10;            int arr[10];&#10;            int* ptr = arr;&#10;            int** double_ptr = &amp;ptr;&#10;            &#10;            for (int i = 0; i &lt; 10; i++) {&#10;                *(ptr + i) = i * 2;&#10;            }&#10;            &#10;            int size = sizeof(arr) / sizeof(int);&#10;            printf(&quot;Taille du tableau: %d\\n&quot;, size);&#10;        }&#10;        `;&#10;&#10;        const compiledCode = compileBaguetteToC(codeBaguette);&#10;        expect(compiledCode.replace(/\s+/g, ' ')).toEqual(expectedC.replace(/\s+/g, ' '));&#10;    });&#10;});" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/tests/detection-mode.test.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/tests/detection-mode.test.ts" />
              <option name="updatedContent" value="import { translate } from '../translator';&#10;import { table, reversedTable } from '../keywords';&#10;&#10;describe('Détection automatique du mode', () =&gt; {&#10;    test('Détection du mode compilation avec code en français', () =&gt; {&#10;        // Test avec un code contenant des mots-clés en français (mode compilation)&#10;        const codeBaguette = 'si (x &gt; 5) retourner 0;';&#10;        const compiledCode = translate(codeBaguette, reversedTable);&#10;        expect(compiledCode).toBe('if (x &gt; 5) return 0;');&#10;    });&#10;&#10;    test('Détection du mode traduction avec code en anglais', () =&gt; {&#10;        // Test avec un code contenant des mots-clés en anglais (mode traduction)&#10;        const codeC = 'if (x &gt; 5) return 0;';&#10;        const translatedCode = translate(codeC, table);&#10;        expect(translatedCode).toBe('si (x &gt; 5) retourner 0;');&#10;    });&#10;&#10;    test('Détection avec des constructions complexes', () =&gt; {&#10;        const codeBaguette = `&#10;        pour (entier i = 0; i &lt; 10; i++) {&#10;            si (i % 2 == 0) continuer;&#10;            enfonctionde (i) {&#10;                lorsque 3: arrêter;&#10;                pardéfaut: retourner;&#10;            }&#10;        }`;&#10;&#10;        const expectedC = `&#10;        for (int i = 0; i &lt; 10; i++) {&#10;            if (i % 2 == 0) continue;&#10;            switch (i) {&#10;                case 3: break;&#10;                default: return;&#10;            }&#10;        }`;&#10;&#10;        const compiledCode = translate(codeBaguette, reversedTable);&#10;        expect(compiledCode.replace(/\s+/g, ' ')).toEqual(expectedC.replace(/\s+/g, ' '));&#10;    });&#10;});" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/tests/integration.test.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/tests/integration.test.ts" />
              <option name="updatedContent" value="import * as fs from 'fs';&#10;import { translate } from '../translator';&#10;import { table, reversedTable } from '../keywords';&#10;import { resolve } from 'path';&#10;&#10;describe('Tests d\'intégration avec fichiers complets', () =&gt; {&#10;    test('Traduction d\'un fichier C complet', () =&gt; {&#10;        // On ne teste qu'un petit extrait pour éviter de rendre le test trop volumineux&#10;        const testFilePath = resolve(__dirname, '../../../test.c');&#10;        const fileContent = fs.readFileSync(testFilePath, 'utf-8');&#10;        &#10;        // On prend juste un extrait représentatif pour le test&#10;        const extract = fileContent.substring(&#10;            fileContent.indexOf('void processState'),&#10;            fileContent.indexOf('cleanup:') + 20&#10;        );&#10;        &#10;        const translatedCode = translate(extract, table);&#10;        &#10;        // Vérifier que les mots-clés C ont bien été traduits en français&#10;        expect(translatedCode).toContain('néant processState');&#10;        expect(translatedCode).toContain('si (s == NULL)');&#10;        expect(translatedCode).toContain('retourner');&#10;        expect(translatedCode).toContain('enfonctionde');&#10;        expect(translatedCode).toContain('lorsque INIT');&#10;        expect(translatedCode).toContain('arrêter');&#10;        expect(translatedCode).toContain('pardéfaut');&#10;        expect(translatedCode).not.toContain('void ');&#10;        expect(translatedCode).not.toContain('if (');&#10;        expect(translatedCode).not.toContain('return;');&#10;        expect(translatedCode).not.toContain('switch');&#10;        expect(translatedCode).not.toContain('case ');&#10;        expect(translatedCode).not.toContain('break;');&#10;        expect(translatedCode).not.toContain('default:');&#10;    });&#10;&#10;    test('Compilation d\'un fichier C complet', () =&gt; {&#10;        // On ne teste qu'un petit extrait pour éviter de rendre le test trop volumineux&#10;        const testFilePath = resolve(__dirname, '../../../test2.c');&#10;        const fileContent = fs.readFileSync(testFilePath, 'utf-8');&#10;        &#10;        // On prend juste un extrait représentatif pour le test&#10;        const extract = fileContent.substring(&#10;            fileContent.indexOf('néant processState'),&#10;            fileContent.indexOf('cleanup:') + 20&#10;        );&#10;        &#10;        const compiledCode = translate(extract, reversedTable);&#10;        &#10;        // Vérifier que les mots-clés français ont bien été traduits en C&#10;        expect(compiledCode).toContain('void processState');&#10;        expect(compiledCode).toContain('if (s == NULL)');&#10;        expect(compiledCode).toContain('return');&#10;        expect(compiledCode).toContain('switch');&#10;        expect(compiledCode).toContain('case INIT');&#10;        expect(compiledCode).toContain('break');&#10;        expect(compiledCode).toContain('default');&#10;        expect(compiledCode).not.toContain('néant ');&#10;        expect(compiledCode).not.toContain('si (');&#10;        expect(compiledCode).not.toContain('retourner;');&#10;        expect(compiledCode).not.toContain('enfonctionde');&#10;        expect(compiledCode).not.toContain('lorsque ');&#10;        expect(compiledCode).not.toContain('arrêter;');&#10;        expect(compiledCode).not.toContain('pardéfaut:');&#10;    });&#10;&#10;    test('Traduction puis recompilation doit donner le code original', () =&gt; {&#10;        const codeC = `&#10;        int main() {&#10;            if (x &gt; 5) {&#10;                return 0;&#10;            }&#10;            for (int i = 0; i &lt; 10; i++) {&#10;                printf(&quot;%d\\n&quot;, i);&#10;            }&#10;            return 1;&#10;        }`;&#10;&#10;        // Traduction C -&gt; C&#10;        const translated = translate(codeC, table);&#10;        &#10;        // Compilation C -&gt; C&#10;        const compiled = translate(translated, reversedTable);&#10;        &#10;        // Le code doit être équivalent à l'original (en ignorant les espaces)&#10;        expect(compiled.replace(/\s+/g, ' ').trim()).toBe(codeC.replace(/\s+/g, ' ').trim());&#10;    });&#10;});" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/translator.test.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/translator.test.ts" />
              <option name="updatedContent" value="import { translate } from './translator';&#10;import { table, reversedTable } from './keywords';&#10;&#10;describe('Fonction de traduction', () =&gt; {&#10;    test('Traduction de C vers Baguette', () =&gt; {&#10;        const codeC = `&#10;        void main() {&#10;            int x = 10;&#10;            if (x &gt; 5) {&#10;                return;&#10;            }&#10;        }&#10;        `;&#10;&#10;        const expectedBaguette = `&#10;        néant main() {&#10;            entier x = 10;&#10;            si (x &gt; 5) {&#10;                retourner;&#10;            }&#10;        }&#10;        `;&#10;&#10;        const translatedCode = translate(codeC, table);&#10;        expect(translatedCode.replace(/\s+/g, ' ')).toEqual(expectedBaguette.replace(/\s+/g, ' '));&#10;    });&#10;&#10;    test('Compilation de Baguette vers C', () =&gt; {&#10;        const codeBaguette = `&#10;        néant main() {&#10;            entier x = 10;&#10;            si (x &gt; 5) {&#10;                retourner;&#10;            }&#10;        }&#10;        `;&#10;&#10;        const expectedC = `&#10;        void main() {&#10;            int x = 10;&#10;            if (x &gt; 5) {&#10;                return;&#10;            }&#10;        }&#10;        `;&#10;&#10;        const compiledCode = translate(codeBaguette, reversedTable);&#10;        expect(compiledCode.replace(/\s+/g, ' ')).toEqual(expectedC.replace(/\s+/g, ' '));&#10;    });&#10;&#10;    test('Traduction avec des mots-clés complexes', () =&gt; {&#10;        const codeC = `&#10;        enum State { INIT, RUNNING };&#10;        struct Data { int value; };&#10;        void process(struct Data *d) {&#10;            static int count = 0;&#10;            switch (count) {&#10;                case 0:&#10;                    break;&#10;                default:&#10;                    return;&#10;            }&#10;        }&#10;        `;&#10;&#10;        const expectedBaguette = `&#10;        énumération State { INIT, RUNNING };&#10;        classe Data { entier value; };&#10;        néant process(classe Data *d) {&#10;            statique entier count = 0;&#10;            enfonctionde (count) {&#10;                lorsque 0:&#10;                    arrêter;&#10;                pardéfaut:&#10;                    retourner;&#10;            }&#10;        }&#10;        `;&#10;&#10;        const translatedCode = translate(codeC, table);&#10;        expect(translatedCode.replace(/\s+/g, ' ')).toEqual(expectedBaguette.replace(/\s+/g, ' '));&#10;    });&#10;&#10;    test('Compilation avec des mots-clés complexes', () =&gt; {&#10;        const codeBaguette = `&#10;        énumération State { INIT, RUNNING };&#10;        classe Data { entier value; };&#10;        néant process(classe Data *d) {&#10;            statique entier count = 0;&#10;            enfonctionde (count) {&#10;                lorsque 0:&#10;                    arrêter;&#10;                pardéfaut:&#10;                    retourner;&#10;            }&#10;        }&#10;        `;&#10;&#10;        const expectedC = `&#10;        enum State { INIT, RUNNING };&#10;        struct Data { int value; };&#10;        void process(struct Data *d) {&#10;            static int count = 0;&#10;            switch (count) {&#10;                case 0:&#10;                    break;&#10;                default:&#10;                    return;&#10;            }&#10;        }&#10;        `;&#10;&#10;        const compiledCode = translate(codeBaguette, reversedTable);&#10;        expect(compiledCode.replace(/\s+/g, ' ')).toEqual(expectedC.replace(/\s+/g, ' '));&#10;    });&#10;&#10;    test('Vérification du mode de détection automatique', () =&gt; {&#10;        // Test avec un code contenant des mots-clés en français (mode compilation)&#10;        const codeBaguette = 'si (x &gt; 5) retourner 0;';&#10;        const compiledCode = translate(codeBaguette, reversedTable);&#10;        expect(compiledCode).toBe('if (x &gt; 5) return 0;');&#10;&#10;        // Test avec un code contenant des mots-clés en anglais (mode traduction)&#10;        const codeC = 'if (x &gt; 5) return 0;';&#10;        const translatedCode = translate(codeC, table);&#10;        expect(translatedCode).toBe('si (x &gt; 5) retourner 0;');&#10;    });&#10;&#10;    test('Test de fichier complet - Traduction de test.c', () =&gt; {&#10;        // Extrait du fichier test.c&#10;        const codeC = `&#10;        void processState(struct ComplexStruct *s) {&#10;            if (s == NULL) {&#10;                return;&#10;            }&#10;            switch (s-&gt;currentState) {&#10;                case INIT:&#10;                    break;&#10;                default:&#10;                    break;&#10;            }&#10;        }`;&#10;&#10;        const expectedBaguette = `&#10;        néant processState(classe ComplexStruct *s) {&#10;            si (s == NULL) {&#10;                retourner;&#10;            }&#10;            enfonctionde (s-&gt;currentState) {&#10;                lorsque INIT:&#10;                    arrêter;&#10;                pardéfaut:&#10;                    arrêter;&#10;            }&#10;        }`;&#10;&#10;        const translatedCode = translate(codeC, table);&#10;        expect(translatedCode.replace(/\s+/g, ' ')).toEqual(expectedBaguette.replace(/\s+/g, ' '));&#10;    });&#10;&#10;    test('Test de fichier complet - Compilation de test2.c', () =&gt; {&#10;        // Extrait du fichier test2.c&#10;        const codeBaguette = `&#10;        néant processState(classe ComplexStruct *s) {&#10;            si (s == NULL) {&#10;                retourner;&#10;            }&#10;            enfonctionde (s-&gt;currentState) {&#10;                lorsque INIT:&#10;                    arrêter;&#10;                pardéfaut:&#10;                    arrêter;&#10;            }&#10;        }`;&#10;&#10;        const expectedC = `&#10;        void processState(struct ComplexStruct *s) {&#10;            if (s == NULL) {&#10;                return;&#10;            }&#10;            switch (s-&gt;currentState) {&#10;                case INIT:&#10;                    break;&#10;                default:&#10;                    break;&#10;            }&#10;        }`;&#10;&#10;        const compiledCode = translate(codeBaguette, reversedTable);&#10;        expect(compiledCode.replace(/\s+/g, ' ')).toEqual(expectedC.replace(/\s+/g, ' '));&#10;    });&#10;});" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/translator.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/translator.ts" />
              <option name="originalContent" value="import { lexer, tokensToString } from './lexer';&#10;import { table, reversedTable } from './keywords';&#10;import { table, reversedTable } from './keywords';&#10;&#10;    // Déterminer si nous sommes en mode compilation (de Baguette vers C) ou traduction (de C vers Baguette)&#10;    const isCompileMode = translationTable === reversedTable;&#10;&#10;    // Analyser le code avec notre lexer avancé&#10;    const tokens = lexer(code, isCompileMode);&#10;&#10;    // Reconstruire le code avec les tokens traités&#10;    return tokensToString(tokens);&#10;" />
              <option name="updatedContent" value="import { translateCToBaguette, compileBaguetteToC } from './lexer';&#10;&#10;export function translate(code: string, translationTable: Record&lt;string, string&gt;): string {&#10;    // Déterminer si nous sommes en mode compilation ou traduction à partir de la table fournie&#10;    const isBaguetteToC = translationTable['néant'] === 'void' || translationTable['si'] === 'if';&#10;    &#10;    if (isBaguetteToC) {&#10;        // Mode compilation : C vers C&#10;        return compileBaguetteToC(code);&#10;    } else {&#10;        // Mode traduction : C vers C&#10;        return translateCToBaguette(code);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>