<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="originalContent" value="# C&#10;&#10;## Le langage de programmation français pour les développeurs qui ont du goût !&#10;&#10;![Version](https://img.shields.io/badge/version-1.0.0-blue)&#10;![Licence](https://img.shields.io/badge/licence-MIT-green)&#10;&#10;## Qu'est-ce que C ?&#10;&#10;C est un transpilateur qui permet de programmer en C mais avec une syntaxe française savoureuse. Fini le temps où vous deviez apprendre l'anglais pour coder ! Avec C, vous pouvez écrire du code dans la langue de Molière tout en profitant de la puissance du langage C.&#10;&#10;## Fonctionnalités ‍&#10;&#10;- **Traduction bidirectionnelle** : Traduisez du C vers C et vice-versa&#10;- **Analyse lexicale intelligente** : Notre lexer comprend le contexte et ne traduit que les vrais mots-clés&#10;- **Conservation du code source** : Les commentaires, chaînes et identifiants restent intacts&#10;- **Interface en ligne de commande simple** : Facile à utiliser&#10;&#10;## Installation &#10;&#10;```bash&#10;# Cloner le dépôt&#10;git clone https://github.com/votre-compte/cbaguette.git&#10;cd cbaguette&#10;&#10;# Installer les dépendances&#10;npm install&#10;&#10;# Compiler le projet&#10;npm run build&#10;```&#10;&#10;## Utilisation &#10;&#10;### Méthode 1 : Via npm start&#10;&#10;```bash&#10;# Traduire du C vers C&#10;npm start -- translate mon_programme.c mon_programme_baguette.cb&#10;&#10;# Compiler du C vers C&#10;npm start -- compile mon_programme_baguette.cb mon_programme.c&#10;```&#10;&#10;### Méthode 2 : Exécuter directement le CLI&#10;&#10;```bash&#10;# Traduire du C vers C&#10;node dist/main.js translate mon_programme.c mon_programme_baguette.cb&#10;&#10;# Compiler du C vers C&#10;node dist/main.js compile mon_programme_baguette.cb mon_programme.c&#10;```&#10;&#10;## Exemples savoureux &#10;&#10;### Programme C standard&#10;&#10;```c&#10;#include &lt;stdio.h&gt;&#10;&#10;int main() {&#10;    printf(&quot;Hello, World!\n&quot;);&#10;    return 0;&#10;}&#10;```&#10;&#10;### Équivalent C&#10;&#10;```c&#10;#include &lt;stdio.h&gt;&#10;&#10;entier main() {&#10;    printf(&quot;Hello, World!\n&quot;);&#10;    retourner 0;&#10;}&#10;```&#10;&#10;### Un exemple plus élaboré&#10;&#10;**Version C :**&#10;```c&#10;#include &lt;stdio.h&gt;&#10;&#10;int factorial(int n) {&#10;    if (n &lt;= 1) return 1;&#10;    return n * factorial(n - 1);&#10;}&#10;&#10;int main() {&#10;    int number = 5;&#10;    printf(&quot;Factorial of %d is %d\n&quot;, number, factorial(number));&#10;    return 0;&#10;}&#10;```&#10;&#10;**Version C :**&#10;```c&#10;#include &lt;stdio.h&gt;&#10;&#10;entier factorial(entier n) {&#10;    si (n &lt;= 1) retourner 1;&#10;    retourner n * factorial(n - 1);&#10;}&#10;&#10;entier main() {&#10;    entier number = 5;&#10;    printf(&quot;Factorial of %d is %d\n&quot;, number, factorial(number));&#10;    retourner 0;&#10;}&#10;```&#10;&#10;## Tableau des mots-clés &#10;&#10;| Mot-clé C | Mot-clé C | Catégorie | Description |&#10;|-----------|-------------------|-----------|-------------|&#10;| `int` | `entier` | Type | Entier |&#10;| `float` | `flottant` | Type | Nombre à virgule flottante |&#10;| `if` | `si` | Contrôle | Condition si |&#10;| `else` | `sinon` | Contrôle | Condition sinon |&#10;| `while` | `tantque` | Contrôle | Boucle tant que |&#10;| `for` | `pour` | Contrôle | Boucle pour |&#10;| `return` | `retourner` | Contrôle | Retourner une valeur |&#10;| ... | ... | ... | ... |&#10;&#10;## Comment ça marche ? &#10;&#10;C utilise un lexer sophistiqué qui analyse le code source et identifie correctement les mots-clés en fonction de leur contexte :&#10;&#10;1. **Analyse lexicale** : Le code est décomposé en tokens (mots-clés, identifiants, chaînes, etc.)&#10;2. **Identification contextuelle** : Le lexer distingue les mots-clés des identifiants&#10;3. **Traduction sélective** : Seuls les vrais mots-clés sont traduits&#10;4. **Reconstruction** : Le code est reconstruit avec les mots-clés traduits&#10;&#10;## Contribution &#10;&#10;Les contributions sont les bienvenues ! N'hésitez pas à :&#10;&#10;- Signaler des bugs&#10;- Proposer de nouvelles fonctionnalités&#10;- Ajouter de nouveaux mots-clés français&#10;- Améliorer la documentation&#10;&#10;## Licence &#10;&#10;Ce projet est sous licence MIT. Voir le fichier LICENSE pour plus de détails.&#10;&#10;## Auteurs et remerciements &#10;&#10;Créé avec amour par des développeurs français qui voulaient coder dans leur langue maternelle tout en restant compatibles avec le C.&#10;&#10;---&#10;&#10;*Ce README a été écrit en français. Si vous ne comprenez pas, utilisez C pour le traduire !* &#10;&#10;---&#10;&#10;&lt;sub&gt;*Ce projet a été vibecodé à partir d'une spec. La puissance de la baguette combinée à la rigueur du code !*&lt;/sub&gt;&#10;" />
              <option name="updatedContent" value="# C&#10;&#10;## Le langage de programmation français pour les développeurs qui ont du goût !&#10;&#10;![Version](https://img.shields.io/badge/version-1.0.0-blue)&#10;![Licence](https://img.shields.io/badge/licence-MIT-green)&#10;&#10;## Qu'est-ce que C ?&#10;&#10;C est un transpilateur qui permet de programmer en C mais avec une syntaxe française savoureuse. Fini le temps où vous deviez apprendre l'anglais pour coder ! Avec C, vous pouvez écrire du code dans la langue de Molière tout en profitant de la puissance du langage C.&#10;&#10;## Fonctionnalités ‍&#10;&#10;- **Traduction bidirectionnelle** : Traduisez du C vers C et vice-versa&#10;- **Analyse lexicale intelligente** : Notre lexer comprend le contexte et ne traduit que les vrais mots-clés&#10;- **Conservation du code source** : Les commentaires, chaînes et identifiants restent intacts&#10;- **Interface en ligne de commande simple** : Facile à utiliser&#10;&#10;## Installation &#10;&#10;```bash&#10;# Cloner le dépôt&#10;git clone https://github.com/votre-compte/cbaguette.git&#10;cd cbaguette&#10;&#10;# Installer les dépendances&#10;npm install&#10;&#10;# Compiler le projet&#10;npm run build&#10;```&#10;&#10;## Utilisation &#10;&#10;### Méthode 1 : Via npm start&#10;&#10;```bash&#10;# Traduire du C vers C&#10;npm start -- translate mon_programme.c mon_programme_baguette.cb&#10;&#10;# Compiler du C vers C&#10;npm start -- compile mon_programme_baguette.cb mon_programme.c&#10;```&#10;&#10;### Méthode 2 : Exécuter directement le CLI&#10;&#10;```bash&#10;# Traduire du C vers C&#10;node dist/main.js translate mon_programme.c mon_programme_baguette.cb&#10;&#10;# Compiler du C vers C&#10;node dist/main.js compile mon_programme_baguette.cb mon_programme.c&#10;```&#10;&#10;## Exemples savoureux &#10;&#10;### Programme C standard&#10;&#10;```c&#10;#include &lt;stdio.h&gt;&#10;&#10;int main() {&#10;    printf(&quot;Hello, World!\n&quot;);&#10;    return 0;&#10;}&#10;```&#10;&#10;### Équivalent C&#10;&#10;```c&#10;#include &lt;stdio.h&gt;&#10;&#10;entier main() {&#10;    printf(&quot;Hello, World!\n&quot;);&#10;    retourner 0;&#10;}&#10;```&#10;&#10;### Un exemple plus élaboré&#10;&#10;**Version C :**&#10;```c&#10;#include &lt;stdio.h&gt;&#10;&#10;int factorial(int n) {&#10;    if (n &lt;= 1) return 1;&#10;    return n * factorial(n - 1);&#10;}&#10;&#10;int main() {&#10;    int number = 5;&#10;    printf(&quot;Factorial of %d is %d\n&quot;, number, factorial(number));&#10;    return 0;&#10;}&#10;```&#10;&#10;**Version C :**&#10;```c&#10;#include &lt;stdio.h&gt;&#10;&#10;entier factorial(entier n) {&#10;    si (n &lt;= 1) retourner 1;&#10;    retourner n * factorial(n - 1);&#10;}&#10;&#10;entier main() {&#10;    entier number = 5;&#10;    printf(&quot;Factorial of %d is %d\n&quot;, number, factorial(number));&#10;    retourner 0;&#10;}&#10;```&#10;&#10;## Tableau des mots-clés &#10;&#10;| Mot-clé C | Mot-clé C | Catégorie | Description |&#10;|-----------|-------------------|-----------|-------------|&#10;| `void` | `néant` | Type | Type vide |&#10;| `char` | `caractère` | Type | Caractère |&#10;| `int` | `entier` | Type | Entier |&#10;| `float` | `flottant` | Type | Nombre à virgule flottante |&#10;| `double` | `flottantprécis` | Type | Flottant double précision |&#10;| `short` | `entiercourt` | Type | Entier court |&#10;| `long` | `entierlong` | Type | Entier long |&#10;| `signed` | `ouijeveuxlesigne` | Type | Avec signe |&#10;| `unsigned` | `jmencarrelaracedusigne` | Type | Sans signe |&#10;| `bool` | `boule` | Type | Booléen |&#10;| `struct` | `classe` | Type | Structure |&#10;| `union` | `union` | Type | Union |&#10;| `enum` | `énumération` | Type | Énumération |&#10;| `if` | `si` | Contrôle | Condition si |&#10;| `else` | `sinon` | Contrôle | Condition sinon |&#10;| `switch` | `enfonctionde` | Contrôle | Sélection multiple |&#10;| `case` | `lorsque` | Contrôle | Cas dans un switch |&#10;| `default` | `pardéfaut` | Contrôle | Cas par défaut |&#10;| `for` | `pour` | Contrôle | Boucle pour |&#10;| `while` | `tantque` | Contrôle | Boucle tant que |&#10;| `do` | `faire` | Contrôle | Boucle faire... tant que |&#10;| `break` | `arrêter` | Contrôle | Sortir d'une boucle |&#10;| `continue` | `continuer` | Contrôle | Passer à l'itération suivante |&#10;| `return` | `retourner` | Contrôle | Retourner une valeur |&#10;| `goto` | `allerà` | Contrôle | Aller à un label |&#10;| `const` | `constante` | Qualificateur | Valeur constante |&#10;| `volatile` | `volatile` | Qualificateur | Variable volatile |&#10;| `restrict` | `restreint` | Qualificateur | Pointeur non aliasé |&#10;| `inline` | `linéarisé` | Qualificateur | Fonction en ligne |&#10;| `sizeof` | `taillede` | Opérateur | Taille en octets |&#10;| `true` | `vrai` | Constante | Vrai |&#10;| `false` | `faux` | Constante | Faux |&#10;| `nullptr` | `pointeurverslenéant` | Constante | Pointeur nul |&#10;| `auto` | `automatique` | Stockage | Variable automatique |&#10;| `static` | `statique` | Stockage | Variable statique |&#10;| `extern` | `externe` | Stockage | Variable externe |&#10;| `typedef` | `enregistrertype` | Stockage | Définition de type |&#10;| `thread_local` | `fillocal` | Stockage | Variable locale au thread |&#10;&#10;## Comment ça marche ? &#10;&#10;C utilise un lexer sophistiqué qui analyse le code source et identifie correctement les mots-clés en fonction de leur contexte :&#10;&#10;1. **Analyse lexicale** : Le code est décomposé en tokens (mots-clés, identifiants, chaînes, etc.)&#10;2. **Identification contextuelle** : Le lexer distingue les mots-clés des identifiants&#10;3. **Traduction sélective** : Seuls les vrais mots-clés sont traduits&#10;4. **Reconstruction** : Le code est reconstruit avec les mots-clés traduits&#10;&#10;## Contribution &#10;&#10;Les contributions sont les bienvenues ! N'hésitez pas à :&#10;&#10;- Signaler des bugs&#10;- Proposer de nouvelles fonctionnalités&#10;- Ajouter de nouveaux mots-clés français&#10;- Améliorer la documentation&#10;&#10;## Licence &#10;&#10;Ce projet est sous licence MIT. Voir le fichier LICENCE pour plus de détails.&#10;&#10;## Auteurs et remerciements &#10;&#10;Créé avec amour par des développeurs français qui voulaient coder dans leur langue maternelle tout en restant compatibles avec le C.&#10;&#10;---&#10;&#10;*Ce README a été écrit en français. Si vous ne comprenez pas, utilisez C pour le traduire !* &#10;&#10;---&#10;&#10;&lt;sub&gt;*Ce projet a été vibecodé à partir d'une spec. La puissance de la baguette combinée à la rigueur du code !*&lt;/sub&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/keywords.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/keywords.ts" />
              <option name="originalContent" value="export const table = {&#10;    alignas: 'alignercomme',&#10;    alignof: 'alignementde',&#10;    auto: 'automatique',&#10;    bool: 'boule',&#10;    break: 'arrêter',&#10;    case: 'lorsque',&#10;    char: 'caractère',&#10;    const: 'constante',&#10;    constexpr: 'expressionconstante',&#10;    continue: 'continuer',&#10;    default: 'pardéfaut',&#10;    do: 'faire',&#10;    double: 'flottantprécis',&#10;    else: 'sinon',&#10;    enum: 'énumération',&#10;    extern: 'externe',&#10;    false: 'faux',&#10;    float: 'flottant',&#10;    for: 'pour',&#10;    goto: 'allerà',&#10;    if: 'si',&#10;    inline: 'linéarisé',&#10;    int: 'entier',&#10;    long: 'entierlong',&#10;    nullptr: 'pointeurverslenéant',&#10;    restrict: 'restreint',&#10;    return: 'retourner',&#10;    short: 'entiercourt',&#10;    signed: 'ouijeveuxlesigne',&#10;    sizeof: 'taillede',&#10;    static: 'statique',&#10;    static_assert: 'ouijesuissurque',&#10;    struct: 'classe',&#10;    switch: 'enfonctionde',&#10;    thread_local: 'fillocal',&#10;    true: 'vrai',&#10;    typedef: 'enregistrertype',&#10;    typeof: 'typede',&#10;    typeof_unqual: 'typedequalifié',&#10;    union: 'union',&#10;    unsigned: 'jmencarrelaracedusigne',&#10;    void: 'néant',&#10;    volatile: 'volatile',&#10;    while: 'tantque',&#10;};&#10;&#10;export const reversedTable = Object.fromEntries(Object.entries(table).map(([key, value]) =&gt; [value, key]));&#10;&#10;" />
              <option name="updatedContent" value="// Définition des mots-clés C avec leurs équivalents en français&#10;export interface KeywordMapping {&#10;    originalKeyword: string;      // Mot-clé C original&#10;    translatedKeyword: string;    // Version française&#10;    category: KeywordCategory;    // Catégorie du mot-clé&#10;    description?: string;         // Description optionnelle&#10;}&#10;&#10;// Catégories de mots-clés&#10;export enum KeywordCategory {&#10;    TYPE = 'type',                // Types de données&#10;    CONTROL_FLOW = 'control',     // Contrôle de flux&#10;    STORAGE = 'storage',          // Spécificateurs de stockage&#10;    OPERATOR = 'operator',        // Opérateurs&#10;    QUALIFIER = 'qualifier',      // Qualificateurs&#10;    CONSTANT = 'constant',        // Constantes&#10;    OTHER = 'other'               // Autres&#10;}&#10;&#10;// Définition structurée des mots-clés&#10;export const KEYWORDS: KeywordMapping[] = [&#10;    // Types de données&#10;    { originalKeyword: 'void', translatedKeyword: 'néant', category: KeywordCategory.TYPE, description: 'Type vide' },&#10;    { originalKeyword: 'char', translatedKeyword: 'caractère', category: KeywordCategory.TYPE, description: 'Caractère' },&#10;    { originalKeyword: 'int', translatedKeyword: 'entier', category: KeywordCategory.TYPE, description: 'Entier' },&#10;    { originalKeyword: 'float', translatedKeyword: 'flottant', category: KeywordCategory.TYPE, description: 'Nombre à virgule flottante' },&#10;    { originalKeyword: 'double', translatedKeyword: 'flottantprécis', category: KeywordCategory.TYPE, description: 'Flottant double précision' },&#10;    { originalKeyword: 'short', translatedKeyword: 'entiercourt', category: KeywordCategory.TYPE, description: 'Entier court' },&#10;    { originalKeyword: 'long', translatedKeyword: 'entierlong', category: KeywordCategory.TYPE, description: 'Entier long' },&#10;    { originalKeyword: 'signed', translatedKeyword: 'ouijeveuxlesigne', category: KeywordCategory.TYPE, description: 'Avec signe' },&#10;    { originalKeyword: 'unsigned', translatedKeyword: 'jmencarrelaracedusigne', category: KeywordCategory.TYPE, description: 'Sans signe' },&#10;    { originalKeyword: 'bool', translatedKeyword: 'boule', category: KeywordCategory.TYPE, description: 'Booléen' },&#10;    &#10;    // Structures de contrôle&#10;    { originalKeyword: 'if', translatedKeyword: 'si', category: KeywordCategory.CONTROL_FLOW, description: 'Condition si' },&#10;    { originalKeyword: 'else', translatedKeyword: 'sinon', category: KeywordCategory.CONTROL_FLOW, description: 'Condition sinon' },&#10;    { originalKeyword: 'switch', translatedKeyword: 'enfonctionde', category: KeywordCategory.CONTROL_FLOW, description: 'Sélection multiple' },&#10;    { originalKeyword: 'case', translatedKeyword: 'lorsque', category: KeywordCategory.CONTROL_FLOW, description: 'Cas dans un switch' },&#10;    { originalKeyword: 'default', translatedKeyword: 'pardéfaut', category: KeywordCategory.CONTROL_FLOW, description: 'Cas par défaut' },&#10;    { originalKeyword: 'for', translatedKeyword: 'pour', category: KeywordCategory.CONTROL_FLOW, description: 'Boucle pour' },&#10;    { originalKeyword: 'while', translatedKeyword: 'tantque', category: KeywordCategory.CONTROL_FLOW, description: 'Boucle tant que' },&#10;    { originalKeyword: 'do', translatedKeyword: 'faire', category: KeywordCategory.CONTROL_FLOW, description: 'Boucle faire... tant que' },&#10;    { originalKeyword: 'break', translatedKeyword: 'arrêter', category: KeywordCategory.CONTROL_FLOW, description: 'Sortir d\'une boucle' },&#10;    { originalKeyword: 'continue', translatedKeyword: 'continuer', category: KeywordCategory.CONTROL_FLOW, description: 'Passer à l\'itération suivante' },&#10;    { originalKeyword: 'return', translatedKeyword: 'retourner', category: KeywordCategory.CONTROL_FLOW, description: 'Retourner une valeur' },&#10;    { originalKeyword: 'goto', translatedKeyword: 'allerà', category: KeywordCategory.CONTROL_FLOW, description: 'Aller à un label' },&#10;    &#10;    // Spécificateurs de stockage&#10;    { originalKeyword: 'auto', translatedKeyword: 'automatique', category: KeywordCategory.STORAGE, description: 'Variable automatique' },&#10;    { originalKeyword: 'static', translatedKeyword: 'statique', category: KeywordCategory.STORAGE, description: 'Variable statique' },&#10;    { originalKeyword: 'extern', translatedKeyword: 'externe', category: KeywordCategory.STORAGE, description: 'Variable externe' },&#10;    { originalKeyword: 'typedef', translatedKeyword: 'enregistrertype', category: KeywordCategory.STORAGE, description: 'Définition de type' },&#10;    { originalKeyword: 'thread_local', translatedKeyword: 'fillocal', category: KeywordCategory.STORAGE, description: 'Variable locale au thread' },&#10;    &#10;    // Qualificateurs&#10;    { originalKeyword: 'const', translatedKeyword: 'constante', category: KeywordCategory.QUALIFIER, description: 'Valeur constante' },&#10;    { originalKeyword: 'volatile', translatedKeyword: 'volatile', category: KeywordCategory.QUALIFIER, description: 'Variable volatile' },&#10;    { originalKeyword: 'restrict', translatedKeyword: 'restreint', category: KeywordCategory.QUALIFIER, description: 'Pointeur non aliasé' },&#10;    { originalKeyword: 'inline', translatedKeyword: 'linéarisé', category: KeywordCategory.QUALIFIER, description: 'Fonction en ligne' },&#10;    &#10;    // Types composés et opérations&#10;    { originalKeyword: 'struct', translatedKeyword: 'classe', category: KeywordCategory.TYPE, description: 'Structure' },&#10;    { originalKeyword: 'union', translatedKeyword: 'union', category: KeywordCategory.TYPE, description: 'Union' },&#10;    { originalKeyword: 'enum', translatedKeyword: 'énumération', category: KeywordCategory.TYPE, description: 'Énumération' },&#10;    { originalKeyword: 'sizeof', translatedKeyword: 'taillede', category: KeywordCategory.OPERATOR, description: 'Taille en octets' },&#10;    &#10;    // Constantes&#10;    { originalKeyword: 'true', translatedKeyword: 'vrai', category: KeywordCategory.CONSTANT, description: 'Vrai' },&#10;    { originalKeyword: 'false', translatedKeyword: 'faux', category: KeywordCategory.CONSTANT, description: 'Faux' },&#10;    { originalKeyword: 'nullptr', translatedKeyword: 'pointeurverslenéant', category: KeywordCategory.CONSTANT, description: 'Pointeur nul' },&#10;    &#10;    // Fonctionnalités C11/C++&#10;    { originalKeyword: 'alignas', translatedKeyword: 'alignercomme', category: KeywordCategory.QUALIFIER, description: 'Alignement' },&#10;    { originalKeyword: 'alignof', translatedKeyword: 'alignementde', category: KeywordCategory.OPERATOR, description: 'Obtenir l\'alignement' },&#10;    { originalKeyword: 'constexpr', translatedKeyword: 'expressionconstante', category: KeywordCategory.QUALIFIER, description: 'Expression constante' },&#10;    { originalKeyword: 'static_assert', translatedKeyword: 'ouijesuissurque', category: KeywordCategory.OTHER, description: 'Assertion statique' },&#10;    { originalKeyword: 'typeof', translatedKeyword: 'typede', category: KeywordCategory.OPERATOR, description: 'Type de l\'expression' },&#10;    { originalKeyword: 'typeof_unqual', translatedKeyword: 'typedequalifié', category: KeywordCategory.OPERATOR, description: 'Type de l\'expression sans qualificateurs' }&#10;];&#10;&#10;// Création des tables de mapping C-&gt;Baguette et Baguette-&gt;C&#10;export const table: Record&lt;string, string&gt; = Object.fromEntries(&#10;    KEYWORDS.map(({ originalKeyword, translatedKeyword }) =&gt; [originalKeyword, translatedKeyword])&#10;);&#10;&#10;export const reversedTable: Record&lt;string, string&gt; = Object.fromEntries(&#10;    KEYWORDS.map(({ originalKeyword, translatedKeyword }) =&gt; [translatedKeyword, originalKeyword])&#10;);&#10;&#10;// Fonction utilitaire pour obtenir tous les mots-clés d'une catégorie&#10;export function getKeywordsByCategory(category: KeywordCategory): KeywordMapping[] {&#10;    return KEYWORDS.filter(keyword =&gt; keyword.category === category);&#10;}&#10;&#10;// Fonction pour vérifier si un mot est un mot-clé original (C)&#10;export function isCKeyword(word: string): boolean {&#10;    return Object.keys(table).includes(word);&#10;}&#10;&#10;// Fonction pour vérifier si un mot est un mot-clé traduit (Baguette)&#10;export function isBaguetteKeyword(word: string): boolean {&#10;    return Object.keys(reversedTable).includes(word);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/lexer.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/lexer.ts" />
              <option name="originalContent" value="export function lexer(code: string): string[] {&#10;    // This regex captures:&#10;    // 1. Preprocessor directives&#10;    // 2. Block comments&#10;    // 3. Line comments&#10;    // 4. String literals (double quoted)&#10;    // 5. Char literals (single quoted)&#10;    // 6. C identifiers&#10;    // 7. Any other character (operators, whitespace, etc.)&#10;    const cTokenizer = /(#.*)|(\/\*[\s\S]*?\*\/)|(\/\/.*)|(&quot;(\\.|[^&quot;\\])*&quot;)|('(\\.|[^'\\])*')|([a-zA-Z_]\w*)|([\s\S])/g;&#10;&#10;    const tokens: string[] = [];&#10;    let match;&#10;    while ((match = cTokenizer.exec(code)) !== null) {&#10;        if (match[0]) {&#10;            tokens.push(match[0]);&#10;        }&#10;    }&#10;    return tokens;&#10;}&#10;&#10;" />
              <option name="updatedContent" value="import { table, reversedTable } from './keywords';&#10;&#10;// Types de tokens&#10;export enum TokenType {&#10;    KEYWORD = 'keyword',&#10;    IDENTIFIER = 'identifier',&#10;    STRING_LITERAL = 'string',&#10;    CHAR_LITERAL = 'char',&#10;    NUMBER = 'number',&#10;    PREPROCESSOR = 'preprocessor',&#10;    COMMENT_BLOCK = 'comment_block',&#10;    COMMENT_LINE = 'comment_line',&#10;    OPERATOR = 'operator',&#10;    PUNCTUATION = 'punctuation',&#10;    WHITESPACE = 'whitespace',&#10;    NEWLINE = 'newline',&#10;    OTHER = 'other'&#10;}&#10;&#10;export interface Token {&#10;    type: TokenType;&#10;    value: string;&#10;    line: number;&#10;    column: number;&#10;}&#10;&#10;export class CLexer {&#10;    private code: string;&#10;    private position: number = 0;&#10;    private line: number = 1;&#10;    private column: number = 1;&#10;    private translationTable: Record&lt;string, string&gt;;&#10;    private isCompileMode: boolean;&#10;    private keywords: Set&lt;string&gt;;&#10;&#10;    constructor(code: string, isCompileMode: boolean = false) {&#10;        this.code = code;&#10;        this.isCompileMode = isCompileMode;&#10;        &#10;        // Déterminer la table de traduction en fonction du mode&#10;        this.translationTable = isCompileMode ? reversedTable : table;&#10;        &#10;        // Créer un ensemble de mots-clés à partir de la table appropriée&#10;        this.keywords = new Set(&#10;            isCompileMode &#10;                ? Object.values(this.translationTable) &#10;                : Object.keys(this.translationTable)&#10;        );&#10;    }&#10;&#10;    public tokenize(): Token[] {&#10;        const tokens: Token[] = [];&#10;        &#10;        while (this.position &lt; this.code.length) {&#10;            const token = this.nextToken();&#10;            if (token) {&#10;                tokens.push(token);&#10;            }&#10;        }&#10;        &#10;        return tokens;&#10;    }&#10;&#10;    private nextToken(): Token | null {&#10;        if (this.position &gt;= this.code.length) {&#10;            return null;&#10;        }&#10;&#10;        const char = this.peek();&#10;        const startLine = this.line;&#10;        const startColumn = this.column;&#10;&#10;        // Espaces blancs&#10;        if (/\s/.test(char)) {&#10;            return this.readWhitespace(startLine, startColumn);&#10;        }&#10;        &#10;        // Commentaires de bloc&#10;        if (char === '/' &amp;&amp; this.peek(1) === '*') {&#10;            return this.readBlockComment(startLine, startColumn);&#10;        }&#10;        &#10;        // Commentaires de ligne&#10;        if (char === '/' &amp;&amp; this.peek(1) === '/') {&#10;            return this.readLineComment(startLine, startColumn);&#10;        }&#10;        &#10;        // Directives de préprocesseur&#10;        if (char === '#' &amp;&amp; (this.column === 1 || this.isWhitespaceBeforeCurrent())) {&#10;            return this.readPreprocessor(startLine, startColumn);&#10;        }&#10;        &#10;        // Chaînes de caractères&#10;        if (char === '&quot;') {&#10;            return this.readString(startLine, startColumn);&#10;        }&#10;        &#10;        // Caractères&#10;        if (char === '\'') {&#10;            return this.readChar(startLine, startColumn);&#10;        }&#10;        &#10;        // Nombres&#10;        if (/[0-9]/.test(char) || (char === '.' &amp;&amp; /[0-9]/.test(this.peek(1)))) {&#10;            return this.readNumber(startLine, startColumn);&#10;        }&#10;        &#10;        // Identifiants et mots-clés&#10;        if (/[a-zA-Z_]/.test(char)) {&#10;            return this.readIdentifierOrKeyword(startLine, startColumn);&#10;        }&#10;        &#10;        // Opérateurs et ponctuation&#10;        return this.readOperatorOrPunctuation(startLine, startColumn);&#10;    }&#10;&#10;    private readWhitespace(startLine: number, startColumn: number): Token {&#10;        let value = '';&#10;        &#10;        while (this.position &lt; this.code.length &amp;&amp; /\s/.test(this.peek())) {&#10;            const char = this.advance();&#10;            value += char;&#10;            &#10;            if (char === '\n') {&#10;                return {&#10;                    type: TokenType.NEWLINE,&#10;                    value,&#10;                    line: startLine,&#10;                    column: startColumn&#10;                };&#10;            }&#10;        }&#10;        &#10;        return {&#10;            type: TokenType.WHITESPACE,&#10;            value,&#10;            line: startLine,&#10;            column: startColumn&#10;        };&#10;    }&#10;&#10;    private readBlockComment(startLine: number, startColumn: number): Token {&#10;        let value = '';&#10;        value += this.advance(); // '/'&#10;        value += this.advance(); // '*'&#10;        &#10;        while (this.position &lt; this.code.length) {&#10;            if (this.peek() === '*' &amp;&amp; this.peek(1) === '/') {&#10;                value += this.advance(); // '*'&#10;                value += this.advance(); // '/'&#10;                break;&#10;            }&#10;            value += this.advance();&#10;        }&#10;        &#10;        return {&#10;            type: TokenType.COMMENT_BLOCK,&#10;            value,&#10;            line: startLine,&#10;            column: startColumn&#10;        };&#10;    }&#10;&#10;    private readLineComment(startLine: number, startColumn: number): Token {&#10;        let value = '';&#10;        value += this.advance(); // '/'&#10;        value += this.advance(); // '/'&#10;        &#10;        while (this.position &lt; this.code.length &amp;&amp; this.peek() !== '\n') {&#10;            value += this.advance();&#10;        }&#10;        &#10;        return {&#10;            type: TokenType.COMMENT_LINE,&#10;            value,&#10;            line: startLine,&#10;            column: startColumn&#10;        };&#10;    }&#10;&#10;    private readPreprocessor(startLine: number, startColumn: number): Token {&#10;        let value = '';&#10;        value += this.advance(); // '#'&#10;        &#10;        // Ignorer les espaces après le #&#10;        while (this.position &lt; this.code.length &amp;&amp; /\s/.test(this.peek()) &amp;&amp; this.peek() !== '\n') {&#10;            value += this.advance();&#10;        }&#10;        &#10;        // Lire la directive&#10;        while (this.position &lt; this.code.length &amp;&amp; this.peek() !== '\n') {&#10;            // Gestion des lignes de continuation&#10;            if (this.peek() === '\\' &amp;&amp; this.peek(1) === '\n') {&#10;                value += this.advance(); // '\'&#10;                value += this.advance(); // '\n'&#10;                continue;&#10;            }&#10;            value += this.advance();&#10;        }&#10;        &#10;        return {&#10;            type: TokenType.PREPROCESSOR,&#10;            value,&#10;            line: startLine,&#10;            column: startColumn&#10;        };&#10;    }&#10;&#10;    private readString(startLine: number, startColumn: number): Token {&#10;        let value = '';&#10;        value += this.advance(); // '&quot;'&#10;        &#10;        while (this.position &lt; this.code.length &amp;&amp; this.peek() !== '&quot;') {&#10;            if (this.peek() === '\\') {&#10;                value += this.advance(); // '\'&#10;                if (this.position &lt; this.code.length) {&#10;                    value += this.advance(); // caractère échappé&#10;                }&#10;            } else {&#10;                value += this.advance();&#10;            }&#10;        }&#10;        &#10;        if (this.position &lt; this.code.length) {&#10;            value += this.advance(); // '&quot;'&#10;        }&#10;        &#10;        return {&#10;            type: TokenType.STRING_LITERAL,&#10;            value,&#10;            line: startLine,&#10;            column: startColumn&#10;        };&#10;    }&#10;&#10;    private readChar(startLine: number, startColumn: number): Token {&#10;        let value = '';&#10;        value += this.advance(); // '\''&#10;        &#10;        while (this.position &lt; this.code.length &amp;&amp; this.peek() !== '\'') {&#10;            if (this.peek() === '\\') {&#10;                value += this.advance(); // '\'&#10;                if (this.position &lt; this.code.length) {&#10;                    value += this.advance(); // caractère échappé&#10;                }&#10;            } else {&#10;                value += this.advance();&#10;            }&#10;        }&#10;        &#10;        if (this.position &lt; this.code.length) {&#10;            value += this.advance(); // '\''&#10;        }&#10;        &#10;        return {&#10;            type: TokenType.CHAR_LITERAL,&#10;            value,&#10;            line: startLine,&#10;            column: startColumn&#10;        };&#10;    }&#10;&#10;    private readNumber(startLine: number, startColumn: number): Token {&#10;        let value = '';&#10;        &#10;        // Nombres hexadécimaux&#10;        if (this.peek() === '0' &amp;&amp; (this.peek(1) === 'x' || this.peek(1) === 'X')) {&#10;            value += this.advance(); // '0'&#10;            value += this.advance(); // 'x' ou 'X'&#10;            &#10;            while (this.position &lt; this.code.length &amp;&amp; /[0-9a-fA-F]/.test(this.peek())) {&#10;                value += this.advance();&#10;            }&#10;        } &#10;        // Nombres octaux&#10;        else if (this.peek() === '0' &amp;&amp; /[0-7]/.test(this.peek(1))) {&#10;            value += this.advance(); // '0'&#10;            &#10;            while (this.position &lt; this.code.length &amp;&amp; /[0-7]/.test(this.peek())) {&#10;                value += this.advance();&#10;            }&#10;        } &#10;        // Nombres décimaux&#10;        else {&#10;            // Partie entière&#10;            while (this.position &lt; this.code.length &amp;&amp; /[0-9]/.test(this.peek())) {&#10;                value += this.advance();&#10;            }&#10;            &#10;            // Partie décimale&#10;            if (this.peek() === '.') {&#10;                value += this.advance(); // '.'&#10;                &#10;                while (this.position &lt; this.code.length &amp;&amp; /[0-9]/.test(this.peek())) {&#10;                    value += this.advance();&#10;                }&#10;            }&#10;            &#10;            // Exposant&#10;            if (this.peek() === 'e' || this.peek() === 'E') {&#10;                value += this.advance(); // 'e' ou 'E'&#10;                &#10;                if (this.peek() === '+' || this.peek() === '-') {&#10;                    value += this.advance(); // '+' ou '-'&#10;                }&#10;                &#10;                while (this.position &lt; this.code.length &amp;&amp; /[0-9]/.test(this.peek())) {&#10;                    value += this.advance();&#10;                }&#10;            }&#10;        }&#10;        &#10;        // Suffixes (L, U, F, etc.)&#10;        while (this.position &lt; this.code.length &amp;&amp; /[a-zA-Z]/.test(this.peek())) {&#10;            value += this.advance();&#10;        }&#10;        &#10;        return {&#10;            type: TokenType.NUMBER,&#10;            value,&#10;            line: startLine,&#10;            column: startColumn&#10;        };&#10;    }&#10;&#10;    private readIdentifierOrKeyword(startLine: number, startColumn: number): Token {&#10;        let value = '';&#10;        &#10;        while (this.position &lt; this.code.length &amp;&amp; /[a-zA-Z0-9_]/.test(this.peek())) {&#10;            value += this.advance();&#10;        }&#10;        &#10;        // Déterminer si c'est un mot-clé ou un identifiant&#10;        const type = this.keywords.has(value) ? TokenType.KEYWORD : TokenType.IDENTIFIER;&#10;        &#10;        return {&#10;            type,&#10;            value,&#10;            line: startLine,&#10;            column: startColumn&#10;        };&#10;    }&#10;&#10;    private readOperatorOrPunctuation(startLine: number, startColumn: number): Token {&#10;        let value = this.advance();&#10;        &#10;        // Opérateurs composés de deux caractères&#10;        const twoCharOps = [&#10;            '++', '--', '+=', '-=', '*=', '/=', '%=', '&amp;=', '|=', '^=', '&lt;&lt;', '&gt;&gt;', &#10;            '==', '!=', '&lt;=', '&gt;=', '&amp;&amp;', '||', '-&gt;', '..'&#10;        ];&#10;        &#10;        if (this.position &lt; this.code.length) {&#10;            const twoChars = value + this.peek();&#10;            &#10;            if (twoCharOps.includes(twoChars)) {&#10;                value += this.advance();&#10;            }&#10;        }&#10;        &#10;        // Déterminer si c'est un opérateur ou une ponctuation&#10;        const type = this.isOperator(value) ? TokenType.OPERATOR : TokenType.PUNCTUATION;&#10;        &#10;        return {&#10;            type,&#10;            value,&#10;            line: startLine,&#10;            column: startColumn&#10;        };&#10;    }&#10;&#10;    private advance(): string {&#10;        if (this.position &gt;= this.code.length) {&#10;            return '';&#10;        }&#10;        &#10;        const char = this.code[this.position];&#10;        this.position++;&#10;        &#10;        if (char === '\n') {&#10;            this.line++;&#10;            this.column = 1;&#10;        } else {&#10;            this.column++;&#10;        }&#10;        &#10;        return char;&#10;    }&#10;&#10;    private peek(offset: number = 0): string {&#10;        const pos = this.position + offset;&#10;        &#10;        if (pos &gt;= this.code.length) {&#10;            return '';&#10;        }&#10;        &#10;        return this.code[pos];&#10;    }&#10;&#10;    private isWhitespaceBeforeCurrent(): boolean {&#10;        let pos = this.position - 1;&#10;        &#10;        while (pos &gt;= 0 &amp;&amp; this.code[pos] !== '\n') {&#10;            if (!/\s/.test(this.code[pos])) {&#10;                return false;&#10;            }&#10;            pos--;&#10;        }&#10;        &#10;        return true;&#10;    }&#10;&#10;    private isOperator(value: string): boolean {&#10;        const operators = [&#10;            '+', '-', '*', '/', '%', '=', '!', '&lt;', '&gt;', '&amp;', '|', '^', '~',&#10;            '++', '--', '+=', '-=', '*=', '/=', '%=', '&amp;=', '|=', '^=',&#10;            '&lt;&lt;', '&gt;&gt;', '&lt;&lt;=', '&gt;&gt;=', '==', '!=', '&lt;=', '&gt;=', '&amp;&amp;', '||', '-&gt;'&#10;        ];&#10;        &#10;        return operators.includes(value);&#10;    }&#10;}&#10;&#10;// Fonction principale pour le lexing&#10;export function lexer(code: string, isCompileMode: boolean = false): string[] {&#10;    const cLexer = new CLexer(code, isCompileMode);&#10;    const tokens = cLexer.tokenize();&#10;    &#10;    // Traiter les tokens et transformer les mots-clés selon le mode&#10;    return processTokens(tokens, isCompileMode);&#10;}&#10;&#10;// Traitement des tokens pour remplacer les mots-clés&#10;function processTokens(tokens: Token[], isCompileMode: boolean): string[] {&#10;    const translationTable = isCompileMode ? reversedTable : table;&#10;    const result: string[] = [];&#10;    &#10;    for (const token of tokens) {&#10;        if (token.type === TokenType.KEYWORD) {&#10;            // Remplacer uniquement les mots-clés&#10;            const translated = translationTable[token.value];&#10;            result.push(translated || token.value);&#10;        } else {&#10;            // Conserver les autres tokens tels quels&#10;            result.push(token.value);&#10;        }&#10;    }&#10;    &#10;    return result;&#10;}&#10;&#10;// Fonction pour reconstituer le code à partir des tokens&#10;export function tokensToString(tokens: string[]): string {&#10;    return tokens.join('');&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/newLexer.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/newLexer.ts" />
              <option name="updatedContent" value="import { table, reversedTable } from './keywords';&#10;&#10;// Types de tokens&#10;export enum TokenType {&#10;    KEYWORD = 'keyword',&#10;    IDENTIFIER = 'identifier',&#10;    STRING_LITERAL = 'string',&#10;    CHAR_LITERAL = 'char',&#10;    NUMBER = 'number',&#10;    PREPROCESSOR = 'preprocessor',&#10;    COMMENT_BLOCK = 'comment_block',&#10;    COMMENT_LINE = 'comment_line',&#10;    OPERATOR = 'operator',&#10;    PUNCTUATION = 'punctuation',&#10;    WHITESPACE = 'whitespace',&#10;    NEWLINE = 'newline',&#10;    OTHER = 'other'&#10;}&#10;&#10;export interface Token {&#10;    type: TokenType;&#10;    value: string;&#10;    line: number;&#10;    column: number;&#10;}&#10;&#10;export class CLexer {&#10;    private code: string;&#10;    private position: number = 0;&#10;    private line: number = 1;&#10;    private column: number = 1;&#10;    private translationTable: Record&lt;string, string&gt;;&#10;    private isCompileMode: boolean;&#10;    private keywords: Set&lt;string&gt;;&#10;&#10;    constructor(code: string, isCompileMode: boolean = false) {&#10;        this.code = code;&#10;        this.isCompileMode = isCompileMode;&#10;        &#10;        // Déterminer la table de traduction en fonction du mode&#10;        this.translationTable = isCompileMode ? reversedTable : table;&#10;        &#10;        // Créer un ensemble de mots-clés à partir de la table appropriée&#10;        this.keywords = new Set(&#10;            isCompileMode &#10;                ? Object.values(this.translationTable) &#10;                : Object.keys(this.translationTable)&#10;        );&#10;    }&#10;&#10;    public tokenize(): Token[] {&#10;        const tokens: Token[] = [];&#10;        &#10;        while (this.position &lt; this.code.length) {&#10;            const token = this.nextToken();&#10;            if (token) {&#10;                tokens.push(token);&#10;            }&#10;        }&#10;        &#10;        return tokens;&#10;    }&#10;&#10;    private nextToken(): Token | null {&#10;        if (this.position &gt;= this.code.length) {&#10;            return null;&#10;        }&#10;&#10;        const char = this.peek();&#10;        const startLine = this.line;&#10;        const startColumn = this.column;&#10;&#10;        // Espaces blancs&#10;        if (/\s/.test(char)) {&#10;            return this.readWhitespace(startLine, startColumn);&#10;        }&#10;        &#10;        // Commentaires de bloc&#10;        if (char === '/' &amp;&amp; this.peek(1) === '*') {&#10;            return this.readBlockComment(startLine, startColumn);&#10;        }&#10;        &#10;        // Commentaires de ligne&#10;        if (char === '/' &amp;&amp; this.peek(1) === '/') {&#10;            return this.readLineComment(startLine, startColumn);&#10;        }&#10;        &#10;        // Directives de préprocesseur&#10;        if (char === '#' &amp;&amp; (this.column === 1 || this.isWhitespaceBeforeCurrent())) {&#10;            return this.readPreprocessor(startLine, startColumn);&#10;        }&#10;        &#10;        // Chaînes de caractères&#10;        if (char === '&quot;') {&#10;            return this.readString(startLine, startColumn);&#10;        }&#10;        &#10;        // Caractères&#10;        if (char === '\'') {&#10;            return this.readChar(startLine, startColumn);&#10;        }&#10;        &#10;        // Nombres&#10;        if (/[0-9]/.test(char) || (char === '.' &amp;&amp; /[0-9]/.test(this.peek(1)))) {&#10;            return this.readNumber(startLine, startColumn);&#10;        }&#10;        &#10;        // Identifiants et mots-clés&#10;        if (/[a-zA-Z_]/.test(char)) {&#10;            return this.readIdentifierOrKeyword(startLine, startColumn);&#10;        }&#10;        &#10;        // Opérateurs et ponctuation&#10;        return this.readOperatorOrPunctuation(startLine, startColumn);&#10;    }&#10;&#10;    private readWhitespace(startLine: number, startColumn: number): Token {&#10;        let value = '';&#10;        &#10;        while (this.position &lt; this.code.length &amp;&amp; /\s/.test(this.peek())) {&#10;            const char = this.advance();&#10;            value += char;&#10;            &#10;            if (char === '\n') {&#10;                return {&#10;                    type: TokenType.NEWLINE,&#10;                    value,&#10;                    line: startLine,&#10;                    column: startColumn&#10;                };&#10;            }&#10;        }&#10;        &#10;        return {&#10;            type: TokenType.WHITESPACE,&#10;            value,&#10;            line: startLine,&#10;            column: startColumn&#10;        };&#10;    }&#10;&#10;    private readBlockComment(startLine: number, startColumn: number): Token {&#10;        let value = '';&#10;        value += this.advance(); // '/'&#10;        value += this.advance(); // '*'&#10;        &#10;        while (this.position &lt; this.code.length) {&#10;            if (this.peek() === '*' &amp;&amp; this.peek(1) === '/') {&#10;                value += this.advance(); // '*'&#10;                value += this.advance(); // '/'&#10;                break;&#10;            }&#10;            value += this.advance();&#10;        }&#10;        &#10;        return {&#10;            type: TokenType.COMMENT_BLOCK,&#10;            value,&#10;            line: startLine,&#10;            column: startColumn&#10;        };&#10;    }&#10;&#10;    private readLineComment(startLine: number, startColumn: number): Token {&#10;        let value = '';&#10;        value += this.advance(); // '/'&#10;        value += this.advance(); // '/'&#10;        &#10;        while (this.position &lt; this.code.length &amp;&amp; this.peek() !== '\n') {&#10;            value += this.advance();&#10;        }&#10;        &#10;        return {&#10;            type: TokenType.COMMENT_LINE,&#10;            value,&#10;            line: startLine,&#10;            column: startColumn&#10;        };&#10;    }&#10;&#10;    private readPreprocessor(startLine: number, startColumn: number): Token {&#10;        let value = '';&#10;        value += this.advance(); // '#'&#10;        &#10;        // Ignorer les espaces après le #&#10;        while (this.position &lt; this.code.length &amp;&amp; /\s/.test(this.peek()) &amp;&amp; this.peek() !== '\n') {&#10;            value += this.advance();&#10;        }&#10;        &#10;        // Lire la directive&#10;        while (this.position &lt; this.code.length &amp;&amp; this.peek() !== '\n') {&#10;            // Gestion des lignes de continuation&#10;            if (this.peek() === '\\' &amp;&amp; this.peek(1) === '\n') {&#10;                value += this.advance(); // '\'&#10;                value += this.advance(); // '\n'&#10;                continue;&#10;            }&#10;            value += this.advance();&#10;        }&#10;        &#10;        return {&#10;            type: TokenType.PREPROCESSOR,&#10;            value,&#10;            line: startLine,&#10;            column: startColumn&#10;        };&#10;    }&#10;&#10;    private readString(startLine: number, startColumn: number): Token {&#10;        let value = '';&#10;        value += this.advance(); // '&quot;'&#10;        &#10;        while (this.position &lt; this.code.length &amp;&amp; this.peek() !== '&quot;') {&#10;            if (this.peek() === '\\') {&#10;                value += this.advance(); // '\'&#10;                if (this.position &lt; this.code.length) {&#10;                    value += this.advance(); // caractère échappé&#10;                }&#10;            } else {&#10;                value += this.advance();&#10;            }&#10;        }&#10;        &#10;        if (this.position &lt; this.code.length) {&#10;            value += this.advance(); // '&quot;'&#10;        }&#10;        &#10;        return {&#10;            type: TokenType.STRING_LITERAL,&#10;            value,&#10;            line: startLine,&#10;            column: startColumn&#10;        };&#10;    }&#10;&#10;    private readChar(startLine: number, startColumn: number): Token {&#10;        let value = '';&#10;        value += this.advance(); // '\''&#10;        &#10;        while (this.position &lt; this.code.length &amp;&amp; this.peek() !== '\'') {&#10;            if (this.peek() === '\\') {&#10;                value += this.advance(); // '\'&#10;                if (this.position &lt; this.code.length) {&#10;                    value += this.advance(); // caractère échappé&#10;                }&#10;            } else {&#10;                value += this.advance();&#10;            }&#10;        }&#10;        &#10;        if (this.position &lt; this.code.length) {&#10;            value += this.advance(); // '\''&#10;        }&#10;        &#10;        return {&#10;            type: TokenType.CHAR_LITERAL,&#10;            value,&#10;            line: startLine,&#10;            column: startColumn&#10;        };&#10;    }&#10;&#10;    private readNumber(startLine: number, startColumn: number): Token {&#10;        let value = '';&#10;        &#10;        // Nombres hexadécimaux&#10;        if (this.peek() === '0' &amp;&amp; (this.peek(1) === 'x' || this.peek(1) === 'X')) {&#10;            value += this.advance(); // '0'&#10;            value += this.advance(); // 'x' ou 'X'&#10;            &#10;            while (this.position &lt; this.code.length &amp;&amp; /[0-9a-fA-F]/.test(this.peek())) {&#10;                value += this.advance();&#10;            }&#10;        } &#10;        // Nombres octaux&#10;        else if (this.peek() === '0' &amp;&amp; /[0-7]/.test(this.peek(1))) {&#10;            value += this.advance(); // '0'&#10;            &#10;            while (this.position &lt; this.code.length &amp;&amp; /[0-7]/.test(this.peek())) {&#10;                value += this.advance();&#10;            }&#10;        } &#10;        // Nombres décimaux&#10;        else {&#10;            // Partie entière&#10;            while (this.position &lt; this.code.length &amp;&amp; /[0-9]/.test(this.peek())) {&#10;                value += this.advance();&#10;            }&#10;            &#10;            // Partie décimale&#10;            if (this.peek() === '.') {&#10;                value += this.advance(); // '.'&#10;                &#10;                while (this.position &lt; this.code.length &amp;&amp; /[0-9]/.test(this.peek())) {&#10;                    value += this.advance();&#10;                }&#10;            }&#10;            &#10;            // Exposant&#10;            if (this.peek() === 'e' || this.peek() === 'E') {&#10;                value += this.advance(); // 'e' ou 'E'&#10;                &#10;                if (this.peek() === '+' || this.peek() === '-') {&#10;                    value += this.advance(); // '+' ou '-'&#10;                }&#10;                &#10;                while (this.position &lt; this.code.length &amp;&amp; /[0-9]/.test(this.peek())) {&#10;                    value += this.advance();&#10;                }&#10;            }&#10;        }&#10;        &#10;        // Suffixes (L, U, F, etc.)&#10;        while (this.position &lt; this.code.length &amp;&amp; /[a-zA-Z]/.test(this.peek())) {&#10;            value += this.advance();&#10;        }&#10;        &#10;        return {&#10;            type: TokenType.NUMBER,&#10;            value,&#10;            line: startLine,&#10;            column: startColumn&#10;        };&#10;    }&#10;&#10;    private readIdentifierOrKeyword(startLine: number, startColumn: number): Token {&#10;        let value = '';&#10;        &#10;        while (this.position &lt; this.code.length &amp;&amp; /[a-zA-Z0-9_]/.test(this.peek())) {&#10;            value += this.advance();&#10;        }&#10;        &#10;        // Déterminer si c'est un mot-clé ou un identifiant&#10;        const type = this.keywords.has(value) ? TokenType.KEYWORD : TokenType.IDENTIFIER;&#10;        &#10;        return {&#10;            type,&#10;            value,&#10;            line: startLine,&#10;            column: startColumn&#10;        };&#10;    }&#10;&#10;    private readOperatorOrPunctuation(startLine: number, startColumn: number): Token {&#10;        let value = this.advance();&#10;        &#10;        // Opérateurs composés de deux caractères&#10;        const twoCharOps = [&#10;            '++', '--', '+=', '-=', '*=', '/=', '%=', '&amp;=', '|=', '^=', '&lt;&lt;', '&gt;&gt;', &#10;            '==', '!=', '&lt;=', '&gt;=', '&amp;&amp;', '||', '-&gt;', '..'&#10;        ];&#10;        &#10;        if (this.position &lt; this.code.length) {&#10;            const twoChars = value + this.peek();&#10;            &#10;            if (twoCharOps.includes(twoChars)) {&#10;                value += this.advance();&#10;            }&#10;        }&#10;        &#10;        // Déterminer si c'est un opérateur ou une ponctuation&#10;        const type = this.isOperator(value) ? TokenType.OPERATOR : TokenType.PUNCTUATION;&#10;        &#10;        return {&#10;            type,&#10;            value,&#10;            line: startLine,&#10;            column: startColumn&#10;        };&#10;    }&#10;&#10;    private advance(): string {&#10;        if (this.position &gt;= this.code.length) {&#10;            return '';&#10;        }&#10;        &#10;        const char = this.code[this.position];&#10;        this.position++;&#10;        &#10;        if (char === '\n') {&#10;            this.line++;&#10;            this.column = 1;&#10;        } else {&#10;            this.column++;&#10;        }&#10;        &#10;        return char;&#10;    }&#10;&#10;    private peek(offset: number = 0): string {&#10;        const pos = this.position + offset;&#10;        &#10;        if (pos &gt;= this.code.length) {&#10;            return '';&#10;        }&#10;        &#10;        return this.code[pos];&#10;    }&#10;&#10;    private isWhitespaceBeforeCurrent(): boolean {&#10;        let pos = this.position - 1;&#10;        &#10;        while (pos &gt;= 0 &amp;&amp; this.code[pos] !== '\n') {&#10;            if (!/\s/.test(this.code[pos])) {&#10;                return false;&#10;            }&#10;            pos--;&#10;        }&#10;        &#10;        return true;&#10;    }&#10;&#10;    private isOperator(value: string): boolean {&#10;        const operators = [&#10;            '+', '-', '*', '/', '%', '=', '!', '&lt;', '&gt;', '&amp;', '|', '^', '~',&#10;            '++', '--', '+=', '-=', '*=', '/=', '%=', '&amp;=', '|=', '^=',&#10;            '&lt;&lt;', '&gt;&gt;', '&lt;&lt;=', '&gt;&gt;=', '==', '!=', '&lt;=', '&gt;=', '&amp;&amp;', '||', '-&gt;'&#10;        ];&#10;        &#10;        return operators.includes(value);&#10;    }&#10;}&#10;&#10;// Fonction principale pour le lexing&#10;export function lexer(code: string, isCompileMode: boolean = false): string[] {&#10;    const cLexer = new CLexer(code, isCompileMode);&#10;    const tokens = cLexer.tokenize();&#10;    &#10;    // Traiter les tokens et transformer les mots-clés selon le mode&#10;    return processTokens(tokens, isCompileMode);&#10;}&#10;&#10;// Traitement des tokens pour remplacer les mots-clés&#10;function processTokens(tokens: Token[], isCompileMode: boolean): string[] {&#10;    const translationTable = isCompileMode ? reversedTable : table;&#10;    const result: string[] = [];&#10;    &#10;    for (const token of tokens) {&#10;        if (token.type === TokenType.KEYWORD) {&#10;            // Remplacer uniquement les mots-clés&#10;            const translated = translationTable[token.value];&#10;            result.push(translated || token.value);&#10;        } else {&#10;            // Conserver les autres tokens tels quels&#10;            result.push(token.value);&#10;        }&#10;    }&#10;    &#10;    return result;&#10;}&#10;&#10;// Fonction pour reconstituer le code à partir des tokens&#10;export function tokensToString(tokens: string[]): string {&#10;    return tokens.join('');&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/translator.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/translator.ts" />
              <option name="originalContent" value="export function translate(code: string, translationTable: Record&lt;string, string&gt;): string {&#10;    // This regex captures:&#10;    // 1. Preprocessor directives&#10;    // 2. Block comments&#10;    // 3. Line comments&#10;    // 4. String literals (double quoted)&#10;    // 5. Char literals (single quoted)&#10;    // 6. C identifiers&#10;    // 7. Any other character (operators, whitespace, etc.)&#10;    const cTokenizer = /(#.*)|(\/\*[\s\S]*?\*\/)|(\/\/.*)|(&quot;(\\.|[^&quot;\\])*&quot;)|('(\\.|[^'\\])*')|([a-zA-Z_]\w*)|([\s\S])/g;&#10;&#10;    return code.replace(cTokenizer, (match, _p, _bc, _lc, _s, _c, identifier) =&gt; {&#10;        // If the match is an identifier and it's in our translation table, translate it.&#10;        if (identifier &amp;&amp; translationTable[identifier]) {&#10;            return translationTable[identifier];&#10;        }&#10;        // Otherwise, return the original match (comment, string, operator, etc.)&#10;        return match;&#10;    });&#10;}&#10;&#10;" />
              <option name="updatedContent" value="import { lexer, tokensToString } from './newLexer';&#10;&#10;export function translate(code: string, translationTable: Record&lt;string, string&gt;): string {&#10;    // Déterminer si nous sommes en mode compilation (de Baguette vers C) ou traduction (de C vers Baguette)&#10;    const isCompileMode = translationTable['vrai'] === 'true' || translationTable['si'] === 'if';&#10;    &#10;    // Analyser le code avec notre lexer avancé&#10;    const tokens = lexer(code, isCompileMode);&#10;    &#10;    // Reconstruire le code avec les tokens traités&#10;    return tokensToString(tokens);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>